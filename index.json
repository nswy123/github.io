[{"categories":["LeetCode"],"content":"LeetCode_twoSum","date":"2020-12-02","objectID":"/leetcode_twosum/","tags":["LeetCode","Golang"],"title":"LeetCode_twoSum","uri":"/leetcode_twosum/"},{"categories":["LeetCode"],"content":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那“两个”整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2020-12-02","objectID":"/leetcode_twosum/:1:0","tags":["LeetCode","Golang"],"title":"LeetCode_twoSum","uri":"/leetcode_twosum/"},{"categories":["LeetCode"],"content":"思路 假设已知一个值，那么另一个值为:target-已知值。 首先最外层写个循环，从第一个开始遍历数组中的每一个数，那么另一个数为target-最外层循环的某个数，再写一个内层循环来寻找到另一个值，返回两数的下标。 ","date":"2020-12-02","objectID":"/leetcode_twosum/:2:0","tags":["LeetCode","Golang"],"title":"LeetCode_twoSum","uri":"/leetcode_twosum/"},{"categories":["LeetCode"],"content":"Go实现 func twoSum(nums []int, target int) []int { for i, x := range nums { // 外层循环返回数组内值的下标i和值x for j := i + 1; j \u003c len(nums); j++ { // 内层循环j从i+1处判断target-num[j]的值是否为外层循环的值 if x+nums[j] == target { return []int{i, j} } } } return nil } ","date":"2020-12-02","objectID":"/leetcode_twosum/:3:0","tags":["LeetCode","Golang"],"title":"LeetCode_twoSum","uri":"/leetcode_twosum/"},{"categories":["Goinaction"],"content":"第二章 快速开始一个Go程序","date":"2020-11-25","objectID":"/goinaction_section2/","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.1 程序架构 程序结构结构图 \" 程序结构 ","date":"2020-11-25","objectID":"/goinaction_section2/:1:0","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.2 main package package main import ( \"log\" \"os\" _ \"github.com/goinaction/code/chapter2/sample/matchers\" \"github.com/goinaction/code/chapter2/sample/search\" // Golang中不允许声明包后不使用，使用_下划线可以让编译器接受这种方式，并调用包内的init函数。 ) // init is called prior to main. // init函数在main函数之前运行 func init() { // Change the device for logging to stdout. // 将默认的标准错误stderr设置为标准输出stdout log.SetOutput(os.Stdout) } // main is the entry point for the program. func main() { // Perform the search for the specified term. search.Run(\"president\") } ","date":"2020-11-25","objectID":"/goinaction_section2/:2:0","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.3 search package ","date":"2020-11-25","objectID":"/goinaction_section2/:3:0","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.3.1 search.go //Preface //匹配器是包含特定信息，用于处理某类数据源的实例。 //框架本身默认实现了一个匹配器 //matchers包中实现了一个RSS匹配器，它知道如何获取读入并查找rss数据源 package search //search文件夹下的每个文件都会以search作为包名 import ( //从标准库中导入代码时，只需要给出包名，编译器会到GOROOT和GOPATH下寻找包 //log包提供打印日志到stdout、stderr或者自定义设备 \"log\" //sync包提供同步goroutine的功能 \"sync\" ) // Knowledge: // map使用hash实现，键值对，引用类型初始化， // 定义: map[KeyType]ValueType // 1.KeyType:键类型 // 2.ValueType:值类型 // map类型初始值为nil，使用make()函数分配内存: // make(map[KeyType]ValueType, [cap]) // cap可选(最好写上)，表示map的容量. // // 注册用于搜索的匹配器映射 // A map of registered matchers for searching. var matchers = make(map[string]Matcher) // 1. 键类型为string，它的值类型为Matcher，make()函数为其分配内存，它会返回两个类型，一个string类型，一个Matcher类型，Matcher类型定义在matcher.go中。 // 2. 这个变量是一个包级变量，因为它没有定义在任何一个函数作用域内 // 3. Go中标识符要么从包里公开要么不公开，导入一个包后程序可以直接访问任何一个公开的标识符(以大写字母开头)，不公开的标识符(以小写字母开头)不能被直接访问，但是可以间接访问。 // knowledge // func声明函数，其后紧随函数名Run、参数searchTerm string、返回值 // 在main中调用: // search.Run(\"president\") // Run performs the search logic. func Run(searchTerm string) { // 获取需要搜索的数据源列表 // 第一件事就是先从互联网上获取数据feeds列表 // Retrieve the list of feeds to search through. feeds, err := RetrieveFeeds() // 1. 调用了search包中的RetrieveFeeds函数，返回两个值， // 一个是一组Feed类型的切片(是一种实现了一个动态数组的引用类型，Go中使用切片操作一组数据，第4章进一步介绍切片) if err != nil { // 2. 第二个返回值是一个错误值，if判断是否真的是一个错误， // 若真的错，调用log中的Fatal函数，其接收这个值并输出错误后终止程序。 log.Fatal(err) // summary：很多语言允许一个函数返回多个值，声明一个返回值和一个错误值，若错误则丢弃返回值，否则会产生更多的错误。译者：在Go标准库中的io.Reader.Read函数中允许返回数据和错误值。 } // 创建一个无缓冲的通道，接收匹配后的结果 // Create an unbuffered channel to receive match results to display. results := make(chan *Result) // 使用了简化声明变量的方式，若声明变量为零值则使用var关键字， // 若非零值或使用函数返回值创建变量，应使用简化变量声明方式。 // Go中，通道channel，映射map，切片slice都是引用类型(需要初始化)，但是通道本身实现的是一组带类型的值，此组值用于在goroutine之间传递数据，而且通道内置同步机制，保证通信安全，第6章进一步介绍。 //以下两行是为了防止程序在全部搜索执行完之前终止 // //Go中main函数返回后,整个程序终止，Go程序终止后还会关闭之前启动了的goroutine，写并发程序的时候，最好就是在main函数返回之前关闭goroutine，有助于减少bug。 // 使用sync包中的WaitGroup函数构造一个waitGroup，以便处理所有的数据源 // WaitGroup是一个计数信号量，使用它统计所有goroutine是否都完成了工作。 // Setup a wait group so we can process all the feeds. var waitGroup sync.WaitGroup // 设置我们需要等待处理的每个数据源的goroutine数量 // Set the number of goroutines we need to wait for while // they process the individual feeds. waitGroup.Add(len(feeds)) //把定义的waitGroup变量的值设置为goroutine启动的数量，每个goroutine完成后，其值会递减，若值为0则代表goroutine所有工作结束。 // Launch a goroutine for each feed to find the results. // 为每个数据源启动一个goroutine来查找结果 for _, feed := range feeds { // for range对feeds切片迭代，range可以迭代数组、字符串、切片、映射和通道 // for range迭代切片时，每次返回两个值，第一个值是迭代的值在切片里的索引位置。第二个值是元素值的一个副本。 // 下划线_占用了索引值的位置，意味着把索引值忽略。 // Retrieve a matcher for the search. // 获取一个用于查找的匹配器 matcher, exists := matchers[feed.Type] // 检查map中是否含有符合数据源类型的值，查找map中的键时，可以赋一个值，也可以赋两个值，第一个值代表map查找到的结果值，第二个值是布尔类型，查找的值存在map中则返回副本，否则返回零值 if !exists { // 判断这个键是否存在于map中，若不存在则使用默认匹配器，这样在不知道数据源具体类型时也可以执行。 matcher = matchers[\"default\"] } // Launch the goroutine to perform the search. // knowledge: // goroutine是一个独立于其它函数的函数，使用go关键字来启动一个goroutine，并对其做并发调度。 // 启动一个goroutine执行搜索 go func(matcher Matcher, feed *Feed) { // 以goroutine的方式启动一个匿名函数，这样可以并发独立的处理每个数据源的数据。 // 指定匿名函数接收两个参数，一个类型为Matcher，一个是指向Feed类型的指针，所以feed是一个指针变量。 // 指针变量方便在函数间共享数据，使用指针变量可以让函数访问并修改一个变量的状态，这个变量可以在其它函数甚至其它goroutine的作用域里声明。 Match(matcher, feed, searchTerm, results) // goroutine第一件事是调用Match函数，参数分别是Matcher类型的值，一个指向Feed类型值的指针，搜索项以及输出结果的通道。 // Matcher函数会搜索数据源的数据，并将匹配结果输出到results通道 waitGroup.Done()//递减WaitGroup的计数。可以看到WaitGroup的值没有传入匿名函数，但是匿名函数依然访问到了这个值。 // 此处应用到了闭包，实际上，searchTerm和results变量也是通过闭包的形式访问的，函数可以直接访问到那些没有作为参数传入的变量。 // 匿名函数实际是直接访问外层函数作用域中声明的这些变量本身，而不是副本。 // matcher和feed变量每次调用值都不同，所以没有使用闭包的方式访问。 }(matcher, feed) // matcher和feed两个变量的值被传入匿名函数，Go中所有的变量都以值的方式传递。 } // Launch a goroutine to monitor when all the work is done. // 启动一个goroutine来监控是否所有工作完成 // 此段代码等看完search包再解释，表面意思是： // 以goroutine方式启动了另一个匿名函数，没有输入参数，使用闭包访问了WaitGroup和results变量。 // 这个goroutine调用了WaitGroup的wait方法，此方法会阻塞goroutine，直到WaitGroup内部计数变为0，之后goroutine调用close函数关闭通道，终止程序。 go func() { // Wait for everything to be processed. // 等候任务完成 waitGroup.Wait() // Close the channel to signal t","date":"2020-11-25","objectID":"/goinaction_section2/:3:1","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.3.2 feed.go package search import ( \"encoding/json\" // json包提供编解码JSON的功能，导入json包的时候需要指定encoding的路径 \"os\" // os包提供访问操作系统的功能，如读文件 ) const dataFile = \"data/data.json\" // 声明了一个叫做dataFile的常量，小写字母开头，所以只能在search包内直接访问，不能暴露到外面 // Feed contains information we need to process a feed. // 声明了一个名为Feed的结构类型，这个类型会对外暴露(大写)，包含3个字段，每个字段类型都是字符串，对应数据文件中各个文档的不同字段。 // `号里面称作标记tag，标记描述了JSON解码的元数据，用于创建Feed类型值的切片。每个标记将结构类型里字段对应到JSON文档里指定名字的字段。 type Feed struct { Name string `json:\"site\"` URI string `json:\"link\"` Type string `json:\"type\"` } // RetrieveFeeds函数读取数据文件，并将每个JSON文档解码，存入一个Feed类型的切片里。 // RetrieveFeeds reads and unmarshals the feed data file. // RetrieveFeeds读取并反序列化源数据文件 // RetrieveFeeds没有参数，返回两个值，第一个值返回的是一个切片，每项指向一个Feed类型的值。 // 第二个值返回的是一个error类型的值，表示函数调用是否成功。 func RetrieveFeeds() ([]*Feed, error) { // Open the file. // 使用os包中的open方法，相对路径进行读取，返回两个值 // 第一个返回值是一个指针，指向File类型。 // 第二个返回值是error类型的值，检查Open调用是否成功，若出错则返回错误代码。 file, err := os.Open(dataFile) if err != nil { return nil, err } // 成功打开文件后： // Schedule the file to be closed once // the function returns. // 当函数返回时关闭文件 defer file.Close() // 在函数返回后defer才会安排执行之后的关闭文件 // defer的目的是提高代码可读性 // Decode the file into a slice of pointers // 将文件解码到一个切片里 // to Feed values. // 这个切片的每一项是一个指向一个Feed类型值的指针 // 名为feeds,值为nil的切片,包含一组指向Feed类型的指针 var feeds []*Feed // 调用json包的NewDecoder函数,在其返回值上调用Decode方法 err = json.NewDecoder(file).Decode(\u0026feeds) // 使用之前调用Open返回的文件句柄调用NewDecoder函数,得到一个指向Decoder类型的值的指针 // 再调用这个指针的Decode方法传入切片的地址,之后Decode方法解码数据文件,解码后的值以Feed类型的形式存入切片里. // We don't need to check for errors, the caller can do this. // 此函数不需要检查错误，调用者会做此事。 return feeds, err // 返回切片和错误值 // func (dec *Decoder) Decode(v interface{}) error // Decode方法接收一个类型为interface{}的值作为参数,此类型比较特殊,一般配合reflect包里提供的反射功能使用 } ","date":"2020-11-25","objectID":"/goinaction_section2/:3:2","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.3.3 match.go/default.go match.go // match.go中包含创建不同类型匹配器的代码,用于在Run函数里对数据的搜索. package search import ( \"log\" ) // Result contains the result of a search. // Result保存搜索的结果 type Result struct { Field string Content string } // Matcher defines the behavior required by types that want // to implement a new search type. // Matcher定义了要实现的新搜索类型的行为 // 声明了一个interface接口,这个接口声明了结构类型或者具名类型需要实现的行为 // Go中的命名惯例是,如果接口类型只包含一个方法,那么这个类型的名字以er结尾,例子中的名字叫做Matcher. // 如果接口类型内部声明了多个方法,其名字需要与其行为体关联 type Matcher interface { Search(feed *Feed, searchTerm string) ([]*Result, error) // 对于Matcher这个接口来说,只声明了一个Search方法,这个方法输入一个指向Feed类型值的指针和一个string类型的搜索项 // 该方法返回两个值,一个指向Result类型值的指针的切片.另一个是错误值.Result类型的声明在上面那个结构类型中 } // Match is launched as a goroutine for each individual feed to run // searches concurrently. // func Match(matcher Matcher, feed *Feed, searchTerm string, results chan\u003c- *Result) { // Perform the search against the specified matcher. searchResults, err := matcher.Search(feed, searchTerm) if err != nil { log.Println(err) return } // Write the results to the channel. for _, result := range searchResults { results \u003c- result } } // Display writes results to the console window as they // are received by the individual goroutines. func Display(results chan *Result) { // The channel blocks until a result is written to the channel. // Once the channel is closed the for loop terminates. for result := range results { log.Printf(\"%s:\\n%s\\n\\n\", result.Field, result.Content) } } default.go // 如果让一个用户定义的类型实现一个接口,这个用户定义的类型要实现接口类型里声明的所有方法 package search // defaultMatcher implements the default matcher. // defaultMatcher实现了默认匹配器 type defaultMatcher struct{} // 使用一个空结构声明了一个名为defaultMatcher的结构类型. // 空结构在创建实例时不会分配任何内存,适合创建没有任何状态的类型 // 默认匹配器不需要维护任何状态,因此只需要实现对应的接口即可 // init registers the default matcher with the program. // init函数将默认匹配器注册到程序里 func init() { var matcher defaultMatcher Register(\"default\", matcher) } // Search implements the behavior for the default matcher. // Search实现了默认匹配器的行为 func (m defaultMatcher) Search(feed *Feed, searchTerm string) ([]*Result, error) { return nil, nil } ","date":"2020-11-25","objectID":"/goinaction_section2/:3:3","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Goinaction"],"content":"2.4 RSS匹配器 package matchers import ( \"encoding/xml\" \"errors\" \"fmt\" \"log\" \"net/http\" \"regexp\" \"github.com/goinaction/code/chapter2/sample/search\" ) type ( // item defines the fields associated with the item tag // in the rss document. item struct { XMLName xml.Name `xml:\"item\"` PubDate string `xml:\"pubDate\"` Title string `xml:\"title\"` Description string `xml:\"description\"` Link string `xml:\"link\"` GUID string `xml:\"guid\"` GeoRssPoint string `xml:\"georss:point\"` } // image defines the fields associated with the image tag // in the rss document. image struct { XMLName xml.Name `xml:\"image\"` URL string `xml:\"url\"` Title string `xml:\"title\"` Link string `xml:\"link\"` } // channel defines the fields associated with the channel tag // in the rss document. channel struct { XMLName xml.Name `xml:\"channel\"` Title string `xml:\"title\"` Description string `xml:\"description\"` Link string `xml:\"link\"` PubDate string `xml:\"pubDate\"` LastBuildDate string `xml:\"lastBuildDate\"` TTL string `xml:\"ttl\"` Language string `xml:\"language\"` ManagingEditor string `xml:\"managingEditor\"` WebMaster string `xml:\"webMaster\"` Image image `xml:\"image\"` Item []item `xml:\"item\"` } // rssDocument defines the fields associated with the rss document. rssDocument struct { XMLName xml.Name `xml:\"rss\"` Channel channel `xml:\"channel\"` } ) // rssMatcher implements the Matcher interface. type rssMatcher struct{} // init registers the matcher with the program. func init() { var matcher rssMatcher search.Register(\"rss\", matcher) } // Search looks at the document for the specified search term. func (m rssMatcher) Search(feed *search.Feed, searchTerm string) ([]*search.Result, error) { var results []*search.Result log.Printf(\"Search Feed Type[%s] Site[%s] For URI[%s]\\n\", feed.Type, feed.Name, feed.URI) // Retrieve the data to search. document, err := m.retrieve(feed) if err != nil { return nil, err } for _, channelItem := range document.Channel.Item { // Check the title for the search term. matched, err := regexp.MatchString(searchTerm, channelItem.Title) if err != nil { return nil, err } // If we found a match save the result. if matched { results = append(results, \u0026search.Result{ Field: \"Title\", Content: channelItem.Title, }) } // Check the description for the search term. matched, err = regexp.MatchString(searchTerm, channelItem.Description) if err != nil { return nil, err } // If we found a match save the result. if matched { results = append(results, \u0026search.Result{ Field: \"Description\", Content: channelItem.Description, }) } } return results, nil } // retrieve performs a HTTP Get request for the rss feed and decodes the results. func (m rssMatcher) retrieve(feed *search.Feed) (*rssDocument, error) { if feed.URI == \"\" { return nil, errors.New(\"No rss feed uri provided\") } // Retrieve the rss feed document from the web. resp, err := http.Get(feed.URI) if err != nil { return nil, err } // Close the response once we return from the function. defer resp.Body.Close() // Check the status code for a 200 so we know we have received a // proper response. if resp.StatusCode != 200 { return nil, fmt.Errorf(\"HTTP Response Error %d\\n\", resp.StatusCode) } // Decode the rss feed document into our struct type. // We don't need to check for errors, the caller can do this. var document rssDocument err = xml.NewDecoder(resp.Body).Decode(\u0026document) return \u0026document, err } ","date":"2020-11-25","objectID":"/goinaction_section2/:4:0","tags":["Notes","Golang"],"title":"Go语言实战第二章_快速开始一个Go程序","uri":"/goinaction_section2/"},{"categories":["Golang"],"content":"Go语言基础_指针","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"Go语言基础_指针 不同于C/C++中，Go语言中的指针不能偏移和运算，是安全指针 概念基础: 指针地址 指针类型 指针取值 ","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"Go语言中的指针 数据载入内存，内存有个地址，这就是指针。为了寻找保存在内存中数据的地址，需要用到指针变量。例如 “你好”是一个程序，程序启动后，加载到内存，用到的内存地址假设为0x123456，此时把“你好”赋值给变量A，把内存地址赋值给变量B，B就是一个指针变量，通过A或者B都可以访问“你好”这个程序。 Go语言指针操作只需要记住两个符号，\u0026为取地址符，*为根据地址进行取值。 ","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/:1:1","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"指针地址和指针类型 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。 取变量指针的语法: ptr := \u0026v // v类型为T // v代表被取地址的变量，类型为T // ptr用于接受地址的变量，ptr的类型为*T，称为T的指针类型，*代表指针 ","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/:1:2","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"指针取值 对普通变量使用\u0026操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，即指针取值 例如 func main() { //指针取值 a := 10 b := \u0026a // 取变量a的地址，将指针保存到b中 fmt.Printf(\"type of b:%T\\n\", b) c := *b // 指针取值（根据指针去内存取值） fmt.Printf(\"type of c:%T\\n\", c) fmt.Printf(\"value of c:%v\\n\", c) } output: type of b:*int type of c:int value of c:10 Summary_clear: 取地址操作符\"\u0026“和取值操作符”“是一对互补操作符。”\u0026“取出地址，”“根据地址取出地址指向的值 变量、指针地址、指针变量、取地址、取值的相互关系和特性: 对变量进行取地址（\u0026）操作，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。 指针传值: func modify1(x int) { x = 100 } // x = 100没有改变原来a的值，你x变化和我a有什么关系？？？ func modify2(x *int) { *x = 100 } // *x = 100,表示*int类型的x值被赋值为100，a的老家被篡改了。 func main() { a := 10 modify1(a) fmt.Println(a) // 10 modify2(\u0026a) fmt.Println(a) // 100 } ","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/:1:3","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"new和make func main() { var a *int *a = 100 fmt.Println(*a) var b map[string]int b[\"沙河娜扎\"] = 100 fmt.Println(b) } 上面的代码会引发panic, 因为对于引用类型的变量，使用的时候不仅要声明它，还要为它分配内存空间，否则值没办法存储。 对于值类型的声明不需要分配内存空间，因为在声明的时候已经默认分配了内存空间。 要分配内存，就引出来new和make。Go语言中new和make是内建的两个函数，主要用来分配内存。 new new是一个内置函数，格式为： func new(Type) *Type Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针 new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值,如: // 初始化 func main() { a := new(int) b := new(bool) fmt.Printf(\"%T\\n\", a) // *int fmt.Printf(\"%T\\n\", b) // *bool fmt.Println(*a) // 0 fmt.Println(*b) // false } 本节开始的示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了： func main() { var a *int a = new(int) *a = 10 fmt.Println(*a) } make make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下： func make(t Type, size ...IntegerType) Type make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。 本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值： func main() { var b map[string]int b = make(map[string]int, 10) b[\"沙河娜扎\"] = 100 fmt.Println(b) } new and make different 二者都是用来做内存分配的。 make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身； new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。 ","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/:1:4","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"Reference: 李文周的博客 ","date":"2020-11-11","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础_指针","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"Go语言基础_function","date":"2020-11-09","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_function/","tags":["Golang基础","Notes"],"title":"Go语言基础_function","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_function/"},{"categories":["Golang"],"content":"Go语言基础_函数 package main import \"fmt\" // 函数 // Go支持函数、匿名函数和闭包 // 函数使用func关键字 // func 函数名(参数)(返回值){ // 函数体 // } // 1.函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。 // 在同一个包内，函数名也称不能重名. // 2.参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。 // 3.返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型， // 多个返回值必须用()包裹，并用,分隔。 // 4.函数体：实现指定功能的代码块。 // 函数调用 // // 注意，调用有返回值的函数时，可以不接收其返回值。 // 参数 // // 类型简写 // func intSum(x, y int) int { // return x + y // } // x的类型被省略 // 可变参数 // // 可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识。 // 注意：可变参数通常要作为函数的最后一个参数。 // 例如: // 见下面第60行 //定义一个不需要参数也没有返回值的函数：sayHello func sayHello() { fmt.Println(\"Hello 沙河小王子！\") } //定义一个接收string类型的name参数 func sayHello2(name string) { fmt.Println(\"Hello \", name) } //定义接收多个参数的函数并且有一个返回值 func intSum(a int, b int) int { ret := a + b return ret } //函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。 func intSum2(a int, b int) (ret int) { ret = a + b return } //当函数返回值类型为slice时，nil看做是一个有效的slice，没必要显示返回一个长度为0的切片。 func someFunc(x string) []int { if x == \"\" { return nil // 没必要返回[]int{} } // ... } //函数接收可变参数,在参数名后面加... 表示可变参数 // 可变参数在函数体中是切片类型 func intSum3(a ...int) int { ret := 0 for _, arg := range a { ret = ret + arg } return ret } ret1 := intSum3() ret2 := intSum3(10) ret3 := intSum3(10, 20) ret4 := intSum3(10, 20, 30) fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60 // 固定参数和可变参数同时出现时，可变参数要放在最后 // go语言的函数中没有默认参数 func intSum4(a int, b ...int) int { ret := a for _, arg := range b { ret = ret + arg } return ret } ret5 := intSum4(100) ret6 := intSum4(100, 10) ret7 := intSum4(100, 10, 20) ret8 := intSum4(100, 10, 20, 30) fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160 // 本质上，函数的可变参数是通过切片来实现的。 //Go语言中函数参数类型简写 func intSum5(a, b int) (ret int) { ret = a + b return } //定义具有多个返回值的函数,多返回值也支持类型简写。 func calc(a, b int) (sum, sub int) { sum = a + b sub = a - b return } func main() { //函数调用 x, y := calc(100, 200) fmt.Println(x, y) } // 函数进阶 // // 变量作用域 // 全局变量 // 全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效 // 局部变量 // 1.函数内定义的变量无法在该函数外使用 /* func testLocalVar() { //定义一个函数局部变量x,仅在该函数内生效 var x int64 = 100 fmt.Printf(\"x=%d\\n\", x) } func main() { testLocalVar() fmt.Println(x) // 此时无法使用变量x } */ // 如果局部变量和全局变量重名，优先访问局部变量。 // 2.语句块定义的变量，通常我们会在, // if条件判断、for循环、switch语句上使用这种定义变量的方式 // 例如: /* func testLocalVar2(x, y int) { fmt.Println(x, y) //函数的参数也是只在本函数中生效 if x \u003e 0 { z := 100 //变量z只在if语句块生效 fmt.Println(z) } //fmt.Println(z)//此处无法使用变量z } */ /* func testLocalVar3() { for i := 0; i \u003c 10; i++ { fmt.Println(i) //变量i只在当前for语句块中生效 } //fmt.Println(i) //此处无法使用变量i } */ // 函数类型与变量 // // 函数类型的关键字type，如: type calculation func(int, int) int // 上面语句定义了一个calculation类型，它是一种函数类型， // 这种函数接收两个int类型的参数并且返回一个int类型的返回值。 // 例如: func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } // add,sub都是calculation类型 // 函数类型变量 // //可以声明函数类型的变量并且为该变量赋值: /* func main() { var c calculation // 声明一个calculation类型的变量c c = add // 把add赋值给c fmt.Printf(\"type of c:%T\\n\", c) // type of c:main.calculation fmt.Println(c(1, 2)) // 像调用add一样调用c f := add // 将函数add赋值给变量f1 fmt.Printf(\"type of f:%T\\n\", f) // type of f:func(int, int) int fmt.Println(f(10, 20)) // 像调用add一样调用f } */ //高阶函数 // 1.函数作为参数 /* func add(x, y int) int { return x + y } // op函数名放到了func前面？ func calc(x, y int, op func(int, int) int) int { return op(x, y) } func main() { ret2 := calc(10, 20, add) fmt.Println(ret2) //30 } */ // 2.函数作为返回值 /*func do(s string) (func(int, int) int, error) { switch s { case \"+\": return add, nil case \"-\": return sub, nil default: err := errors.New(\"无法识别的操作符\") return nil, err } }*/ // 匿名函数和闭包 // 匿名函数 // 匿名函数就是没有函数名的函数,format: /* func(参数)(返回值){ 函数体 }*/ // 匿名函数需要保存到某个变量或者作为立即执行函数: /*func main() { // 将匿名函数保存到变量 add := func(x, y int) { // save to add fmt.Println(x + y) } add(10, 20) // 通过变量调用匿名函数 //自执行函数：匿名函数定义完加()直接执行 func(x, y int) { fmt.Println(x + y) }(10, 20) }*/ // 闭包 // // 指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境 // 例如 /*func adder() func(int) int { // 好像还是个匿名函数 var x int return func(y int) int { x += y return x } } func main() { var f = adder() fmt.Println(f(10)) //10 fmt.Println(f(20)) //30 fmt.Println","date":"2020-11-09","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_function/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础_function","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_function/"},{"categories":["Golang"],"content":"Reference: 李文周的博客 ","date":"2020-11-09","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_function/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础_function","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_function/"},{"categories":["Goinaction"],"content":"第一章.关于Go语言的介绍","date":"2020-11-09","objectID":"/goinaction_section1/","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["Goinaction"],"content":"1.Go解决现代编程的问题 ","date":"2020-11-09","objectID":"/goinaction_section1/:1:0","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["Goinaction"],"content":"1.1开发速度快 现代硬件编译整个Go语言的源码树只需要20秒 ","date":"2020-11-09","objectID":"/goinaction_section1/:1:1","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["Goinaction"],"content":"1.2并发 可以说是Go语言最重要的特性了。 goroutine占用内存远小于线程，且使用goroutine的代码少。 内置数据结构channel在goroutine间同步发送消息，无需争夺数据控制权 goroutine goroutine之间可以并行执行，也可与主函数并行执行。 goroutine使用一个线程可以执行多个goroutine 例如，写web服务器，使用net/http库直接使用内置的goroutine 通道 同一时刻只有一个goroutine修改数据，通道在几个运行的goroutine之间发送数据 不需要任何锁或者同步机制。若读和写有不同的goroutine完成则需要额外的同步操作 ","date":"2020-11-09","objectID":"/goinaction_section1/:1:2","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["Goinaction"],"content":"1.3Go语言的类型系统 Go提供了灵活的无继承的类型系统，采用组合设计模式。允许对行为建模，而不是对类型建模。 类型简单 不仅有int和string内置类型，也可以自定义类型。类似于c语言中的结构，不是很懂。。 Go接口对一组行为建模 接口描述类型的行为，若实例实现一个接口，则执行一组特定的行为。即鸭子类型，若它叫起来像鸭子，那么它就可能是只鸭子。 ","date":"2020-11-09","objectID":"/goinaction_section1/:1:3","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["Goinaction"],"content":"1.4内存管理 Go垃圾回收机制会使用一部分额外的花销，但是无需进行内存管理。 ","date":"2020-11-09","objectID":"/goinaction_section1/:1:4","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["Goinaction"],"content":"2.Hello,Go package main import \"fmt\" func main(){ fmt.Println(\"Hello, World!\") } // go build main.go // ./main 在线可以使用Go Playground ","date":"2020-11-09","objectID":"/goinaction_section1/:2:0","tags":["Notes","Golang"],"title":"Go语言实战第一章_关于Go语言的介绍","uri":"/goinaction_section1/"},{"categories":["随笔"],"content":"假装有标题 看风景，听音乐 九号教学楼1十月份的旧图，美吗 \" 九号教学楼1 九号教学楼2十月份的旧图，美吧 \" 九号教学楼2 九号教学楼3十月份的旧图，很美 \" 九号教学楼3 ","date":"2020-11-09","objectID":"/20201109-%E6%9D%82%E8%AE%B0/:1:0","tags":["Notes","杂记"],"title":"2020年11月09日","uri":"/20201109-%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"Go语言基础_map","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_map/","tags":["Golang基础","Notes"],"title":"Go语言基础_map","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_map/"},{"categories":["Golang"],"content":"Go语言基础_map package main import ( \"fmt\" \"strings\" ) // map(映射),使用散列表hash实现 // 无序的，基于键值的数据结构 // map是引用类型，需初始化 // 定义: map[KeyType]ValueType // 1.KeyType:键类型 // 2.ValueType:值类型 // map类型初始值为nil，使用make()函数分配内存: // make(map[KeyType]ValueType, [cap]) // cap可选(最好写上)，表示map的容量. func main() { // map的基本使用 // // scoreMap := make(map[string]int, 8) // scoreMap[\"张三\"] = 90 // scoreMap[\"小明\"] = 100 // fmt.Println(scoreMap) // fmt.Println(scoreMap[\"小明\"]) // fmt.Printf(\"type of a:%T\\n\", scoreMap) // // output: // map[小明:100 张三:90] // 100 // type of a:map[string]int // // map支持声明的时候填充元素，例如: // userInfo := map[string]string{ // \"username\": \"沙河\", // \"password\": \"123456\", // } // fmt.Println(userInfo) // 判断某个键是否存在 // // 判断map中键是否存在的一个特殊写法: // value, ok := map[key] // 例如: scoreMap := make(map[string]int) scoreMap[\"张三\"] = 90 scoreMap[\"小明\"] = 100 // 如果key存在,则ok为true,v为对应的值；不存在key，则ok为false,v为值类型的零值 v, ok := scoreMap[\"张三\"] if ok { fmt.Println(v) } else { fmt.Println(\"查无此人\") } // output: 90 // map的遍历 // // 使用 for range 遍历map // scoreMap := make(map[string]int) // scoreMap[\"张三\"] = 90 // scoreMap[\"小明\"] = 100 // scoreMap[\"娜扎\"] = 60 // for k, v := range scoreMap { // fmt.Println(k, v) // } // 注意： 遍历map时的元素顺序与添加键值对的顺序无关。 // 使用delete()函数删除键值对 // // delete()内建函数从map中删除一组键值对，格式为: // delete(map, key) // 1.map:要删除键值对的map // 2.key:要删除键值对的键 // 例如: // scoreMap := make(map[string]int) // scoreMap[\"张三\"] = 90 // scoreMap[\"小明\"] = 100 // scoreMap[\"娜扎\"] = 60 // delete(scoreMap, \"小明\")//将小明:100从map中删除 // for k,v := range scoreMap{ // fmt.Println(k, v) // } // 按照指定顺序遍历map // // rand.Seed(time.Now().UnixNano()) //初始化随机数种子 // var scoreMap = make(map[string]int, 200) // for i := 0; i \u003c 100; i++ { // key := fmt.Sprintf(\"stu%02d\", i) //生成stu开头的字符串 // value := rand.Intn(100) //生成0~99的随机整数 // scoreMap[key] = value // } // //取出map中的所有key存入切片keys // var keys = make([]string, 0, 200) // for key := range scoreMap { // keys = append(keys, key) // } // //对切片进行排序 // sort.Strings(keys) // //按照排序后的key遍历map // for _, key := range keys { // fmt.Println(key, scoreMap[key]) // } // 元素为map类型的切片 // // var mapSlice = make([]map[string]string, 3) // for index, value := range mapSlice { // fmt.Printf(\"index:%d value:%v\\n\", index, value) // } // fmt.Println(\"after init\") // // 对切片中的map元素进行初始化 // mapSlice[0] = make(map[string]string, 10) // mapSlice[0][\"name\"] = \"小王子\" // mapSlice[0][\"password\"] = \"123456\" // mapSlice[0][\"address\"] = \"沙河\" // for index, value := range mapSlice { // fmt.Printf(\"index:%d value:%v\\n\", index, value) // } // 值为切片类型的map // var sliceMap = make(map[string][]string, 3) // fmt.Println(sliceMap) // fmt.Println(\"after init\") // key := \"中国\" // value, ok := sliceMap[key] // if !ok { // value = make([]string, 0, 2) // } // value = append(value, \"北京\", \"上海\") // sliceMap[key] = value // fmt.Println(sliceMap) // 统计一个字符串中每个单词出现的次数 // \"how do you do\"中每个单词出现的次数 // 0. 定义一个map[string]int var s = \"how do you do\" var wordCount = make(map[string]int, 10) // 1. 字符串中都有哪些单词 words := strings.Split(s, \" \") // 2. 遍历单词做统计 for _, word := range words { v, ok := wordCount[word] if ok { // map中有这个单词的统计记录 wordCount[word] = v + 1 } else { // map中没有这个单词的统计记录 wordCount[word] = 1 } } for k, v := range wordCount { fmt.Println(k, v) } } ","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_map/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础_map","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_map/"},{"categories":["Golang"],"content":"Reference: 李文周的博客 ","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_map/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础_map","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_map/"},{"categories":["Golang"],"content":"Go语言基础_数组","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84/","tags":["Golang基础","Notes"],"title":"Go语言基础_数组","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84/"},{"categories":["Golang"],"content":"Go语言基础_数组 package main import \"fmt\" // 数组相关内容 func main() { // var a [3]int // 长度为3，元素类型为int的数组a // var b [4]int // 长度为4，元素类型为int的数组b // a = b // a和b不同类型(数组的长度是类型的一部分)，所以不能把b赋给a // 数组通过下标访问，长度从0 to len-1 // fmt.Println(a) // fmt.Println(b) // 数组的初始化 // 1. 定义时使用初始值列表的方式初始化 // var cityArray = [4]string{\"北京\", \"上海\", \"广州\", \"深圳\"} // fmt.Println(cityArray) // [北京，上海，广州，深圳] // fmt.Println(cityArray[0]) // [北京] // fmt.Println(cityArray[3]) // [深圳] // // 2. 编译器推导数组的长度 // var boolArray = [...]bool{true, false, false, true, false} // fmt.Println(boolArray) // 5 // // 3. 使用索引值方式初始化 // var langArray = [...]string{1: \"Golang\", 3: \"Python\", 7: \"Java\"} // 索引的格式\"number:\",长度为最后一个number加1，即从下标0开始 // fmt.Println(langArray) // [Golang Python Java] // fmt.Printf(\"%T\\n\", langArray) //[8]string // 数组的遍历 // var cityArray = [4]string{\"北京\", \"上海\", \"广州\", \"深圳\"} // 1. for循环遍历 // for i := 0; i \u003c len(cityArray); i++ { // fmt.Println(cityArray[i]) // } // Notice: for循环中使用分号分割，左大括号需要和for关键字一行，len()为计算数组长度的函数 // 2. for range遍历 // for _, value := range cityArray { // fmt.Println(value) // } // for 循环的判断条件若省略使用下划线_,且使用逗号分割,此方法使用的是for range循环 // 二维数组(又称嵌套数组) // cityArray := [...][2]string{ // {\"北京\", \"西安\"}, // {\"上海\", \"杭州\"}, // {\"重庆\", \"成都\"}, // {\"广州\", \"深圳\"}, // } // fmt.Println(cityArray) // [[北京 西安] [上海 杭州] [重庆 成都] [广州 深圳]] // fmt.Println(cityArray[2][0]) // 第2行第0列-重庆 // // // 二维数组的遍历 // for _, v1 := range cityArray { // v1表示range 整个数组 // fmt.Println(v1) // for _, v2 := range v1 { // v2表示range到 v1 // fmt.Println(v2) // } // 建议查一下range函数的使用 // } // 多维数组只有第一层可以用[...]来推导数组长度 // 数组是值类型 // 值类型意味着数组在赋值和传参的时候操作都是副本的值，并不改变原数组的值。 x := [3][2]int{ {1, 2}, {3, 4}, {5, 6}, } fmt.Println(x) f1(x) fmt.Println(x) y := x y[0][0] = 1000 fmt.Println(x) } func f1(a [3][2]int) { a[0][0] = 100 } ","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础_数组","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84/"},{"categories":["Golang"],"content":"Reference: 李文周的博客 ","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础_数组","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84/"},{"categories":["Golang"],"content":"Go语言基础_切片","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87/","tags":["Golang基础","Notes"],"title":"Go语言基础_切片","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"Go语言基础_切片 package main import \"fmt\" // 引文 // 数组的长度固定，且数组长度属于类型的一部分，所以限制比较多 // func arraySum(x [3]int) int{ // sum := 0 // for _, v := range x{ // sum = sum + v // } // return sum //} //上例中数组是固定的三个int类型的值，因此调用时候只接受[3]int类型， //受限制比较多，因此引入切片。 // 切片 // // 1.切片是具有相同类型元素的可变长序列 // // 2.切片是基于数组做了一层封装，可以自动扩容 // // 3.切片是引用类型，内部结构包含地址、长度和容量 // // 4.切片一般用于快速的操作一块数据集合 // 切片的底层就是数组 // 切片类型的基本语法: // var name []T // name:变量名 // T:切片中的元素类型 func main() { // 声明切片类型 var a []string //声明一个字符串切片, 默认为nil var b = []int{} //声明一个整型切片并初始化, 默认不为nil var c = []bool{false, true} //声明一个布尔切片并初始化 var d = []bool{false, true} //声明一个布尔切片并初始化 fmt.Println(a) //[] fmt.Println(b) //[] fmt.Println(c) //[false true] fmt.Println(a == nil) //true fmt.Println(b == nil) //false fmt.Println(c == nil) //false fmt.Println(d != nil) // fmt.Println(c == d) //切片是引用类型，不支持直接比较，只能和nil比较 // 基于数组的切片 e := [5]int{55, 56, 57, 58, 59} f := e[1:4] //索引切片的值 fmt.Println(f) fmt.Printf(\"%T\\n\", f) // %T要用printf函数 fmt.Printf(\"f:%v len(f):%v cap(f):%v\\n\", f, len(f), cap(f)) // 切片的长度和容量 // 内置函数求切片的长度和容量: // len() // length // cap() //cap // 切片表达式 // 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片： // 1. 指定low和high两个索引界限值 // 2. 除了low和high两个索引界限值外，还指定容量的完整的形式 // // // 1.简单切片表达式 // // func main() { // // a := [5]int{1, 2, 3, 4, 5} // // s := a[1:3] // s := a[low:high],左包含右不包含,所以长度=high-low， // 容量等于得到的切片的底层数组的容量,容量暂时不是很明白，我猜测是不是数组长度为5， // 也就是0-4，所以底层数组的容量是4？切片的容量也就是4. // // fmt.Printf(\"s:%v len(s):%v cap(s):%v\\n\", s, len(s), cap(s)) // 输出 s:[2 3] len(s):2 cap(s):4 // Notice: // 1.类似于matlab中，若low省略则从0开始，若high省略则为切片操作数的长度 // 2.数组和字符串，0 \u003c= low \u003c= high \u003c= len(a)则合法，否则越界 // 3.切片再切片的时候，high的上限是切片的容量cap(a),不是长度。常量索引必须非负 // 索引的上限是cap(s)而不是len(s) s2 := f[3:4] fmt.Printf(\"s2:%v len(s2):%v cap(s2):%v\\n\", s2, len(s2), cap(s2)) // s:[2 3] len(s):2 cap(s):4 // s2:[5] len(s2):1 cap(s2):1 // s2上限为cap()，为什么值为最后一位？ // 答:见go语言实战第64页图4-12，在进行一次切片时，只看low这个值的地址， // 这个值的地址变成了0，下一次切片的时候从这个地方开始数，high则为cap()， // 即从low变为0的地方开始数到原数组的最后一位。 // // // 2.完整切片表达式 // 数组、指向数组的指针、或切片a(不能是字符串)支持 // a[low : high : max] // a[low : high] // 上述构造的切片相同类型、相同长度、相同元素。 // 完整切片的容量被设置为max-low，且只能省略low，默认为0 t := e[1:3:5] fmt.Printf(\"t:%v len(t):%v cap(t)%v\\n\", t, len(t), cap(t)) // t:[2 3] len(t):2 cap(t):4 // 使用make()函数构造切片 // // 动态的创建切片，使用make()函数 // make([]T, size, cap) // 1.T:切片的元素类型 // 2.size:切片中元素的数量 // 3.cap:切片的容量 g := make([]int, 2, 10) // length:2 // capacity:10 fmt.Println(g) //[0 0] fmt.Println(len(g)) //2 fmt.Println(cap(g)) //10 // 切片的本质 // // 本质是对底层数组的封装，包括: // 1.底层数组的指针 // 2.切片的长度len // 3.切片的容量cap // 判断切片是否为空 // // len(s) == 0 // 不可使用 s == nil // // 切片不能直接比较 // 不能使用==判断两个切片是否含有全部相等的元素 // 切片唯一可以合法比较是和nil，一个nil值的切片没有底层数组， // 长度和容量都是0，反之不一定 // var s1 []int //len(s1)=0;cap(s1)=0;s1==nil // s2 := []int{} //len(s2)=0;cap(s2)=0;s2!=nil // s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil // 切片的赋值拷贝 // // 拷贝前后两个变量共享底层数组，对一个切片的修改影响另一个切片的内容 // s1 := make([]int, 3) //[0 0 0] // s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 // s2[0] = 100 // fmt.Println(s1) //[100 0 0] // fmt.Println(s2) //[100 0 0] // 切片的遍历 // // 与数组一致，索引遍历和 for range 遍历 // s := []int{1, 3, 5} // for i := 0; i \u003c len(s); i++ { // fmt.Println(i, s[i]) // } // for index, value := range s { // fmt.Println(index, value) // } // append()方法为切片添加元素 // // 1.动态添加元素 // 2.一次一个或多个元素 // 3.也可添加另一个切片中的元素 // var s []int // s = append(s, 1) // [1] // s = append(s, 2, 3, 4) // [1 2 3 4] // s2 := []int{5, 6, 7} // s = append(s, s2...) // [1 2 3 4 5 6 7] // 注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。 // 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。 // 当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”， // 此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时， // 所以我们通常都需要用原变量接收append函数的返回值 // 举例: // func main() { // append()添加元素和切片扩容 // var numSlice []int // for i := 0; i \u003c 10; i++ { // numSlice = append(numSlice, i) // fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", numSlice, len(numSlice), cap(numSlice), numSlice) // } // } // output: // [0] len:1 cap:1 ptr:0xc0000a8000 // [0 1] len:2 cap:2 ptr:0xc0000a8040 // [0 1 2] len:3 cap:4 ptr:0xc0000b2020 // [0 1 2 3] len:4 cap:4 pt","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础_切片","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"Reference: 李文周的博客 ","date":"2020-11-08","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础_切片","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87/"},{"categories":["Linux"],"content":"shell-倒计时程序","date":"2020-11-05","objectID":"/count_down/","tags":["Shell","Linux"],"title":"shell-倒计时程序","uri":"/count_down/"},{"categories":["Linux"],"content":"shell_countDown #!/bin/bash read -p \"please input time like[5.3](it means 5min3sec):\" TIME minute=`echo $TIME | awk -F . '{print $1}'` second=`echo $TIME | awk -F . '{print $2}'` #echo \"After 3 second , the game will begin.\" #for i in 3 2 1 #do # echo $i # sleep 1 #done echo \"-------------------------\" while (( $minute \u003e=0 )) do if [ $second = 0 ]\u0026\u0026[ $minute = 0 ] then echo \"time over！！\" exit elif (( $second \u003e= 0 )) then echo $minute:$second | tr \"\\n\" \"\\r\" (( second-- )) sleep 1 elif (( $second\u003c0 )) then (( minute-- )) (( second=59 )) fi done Reference ","date":"2020-11-05","objectID":"/count_down/:1:0","tags":["Shell","Linux"],"title":"shell-倒计时程序","uri":"/count_down/"},{"categories":["PDF"],"content":"Linux下PDF压缩转换等常用操作","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"2020年11月15日更新，增加PDF转图片格式的内容 ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:0:0","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"Preface 以下操作是linux下对pdf文件的一些常用操作 如果没有安装过ghostscript这个软件，需要提前安装，因为gs命令会使用到它，在manjaro或者arch下 sudo pacman -S ghostscript ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:1:0","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"多个PDF合并成为一个 pdfunite [options] PDF-sourcefile1..PDF-sourcefilen PDF-destfile # 使用man pdfunite查看更多使用方法和相关命令 ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:2:0","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"PDF转换成其它格式 pdftocairo [options] PDF-file [output-file] # pdftocairo -Portable Document Format (PDF) to PNG/JPEG/TIFF/PDF/PS/EPS/SVG using cairo ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:3:0","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"PDF压缩 ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:4:0","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"gs命令压缩(建议) gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile=output.pdf input.pdf # output.pdf:输出文件名 # input.pdf:输入文件名 # -dPDFSETTINGS=/screen:可设置为其它，具体请man一下gs ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:4:1","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"采用ps2pdf命令压缩(不建议) ps2pdf input.pdf output.pdf 不建议使用这种方式，是因为不是所有pdf都可以用这种方法压缩到令人满意的程度。 ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:4:2","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["PDF"],"content":"pdf 转换为图片格式 gs -sDEVICE=jpeg -o %03d.jpg -sDEVICE=jpeg -r300 input.pdf # 转png或者jpg格式或者其它图片格式自己设置，-sDEVICE可以参考官方文档，下面给了链接 # 我个人仅用到了jpg格式的图片所以贴出上述命令，-sDEVICE还可以设置为pngalpha等，有需要可以尝试直到自己满意的程度。 更多使用方法请点击官方文档 Ghostscript ","date":"2020-11-04","objectID":"/pdf%E6%93%8D%E4%BD%9C/:5:0","tags":["“LaTeX\"","PDF","Linux"],"title":"Linux下PDF压缩转换等常用操作","uri":"/pdf%E6%93%8D%E4%BD%9C/"},{"categories":["emacs"],"content":"doom-emacs的配置文件(LST)","date":"2020-11-04","objectID":"/doom-emacs-configure/","tags":["manjaro","doom-emacs"],"title":"doom-emacs的配置文件(LST)","uri":"/doom-emacs-configure/"},{"categories":["emacs"],"content":"config.el ;;; $DOOMDIR/config.el -*- lexical-binding: t; -*- ;; Place your private configuration here! Remember, you do not need to run 'doom ;; sync' after modifying this file! ;; Some functionality uses this to identify you, e.g. GPG configuration, email ;; clients, file templates and snippets. (setq user-full-name \"nswy123\" user-mail-address \"nswy123@126.com\") ;; Doom exposes five (optional) variables for controlling fonts in Doom. Here ;; are the three important ones: ;; ;; + `doom-font' ;; + `doom-variable-pitch-font' ;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for ;; presentations or streaming. ;; ;; They all accept either a font-spec, font string (\"Input Mono-12\"), or xlfd ;; font string. You generally only need these two: ;; (setq doom-font (font-spec :family \"monospace\" :size 12 :weight 'semi-light) ;; doom-variable-pitch-font (font-spec :family \"sans\" :size 13)) (setq doom-font (font-spec :family \"Fira Code\" :size 19)) ;;(when (member \"Sarasa Nerd\" (font-family-list)) ;; (setq doom-font (font-spec :family \"Sarasa Nerd\" :size 16) ;; doom-variable-pitch-font (font-spec :family \"Sarasa Nerd\") ;; doom-unicode-font (font-spec :family \"Sarasa Nerd\") ;; doom-big-font (font-spec :family \"Sarasa Nerd\" :size 20))) ;;(defun +my/better-font() ;; (interactive) ;; ;; english font ;; (if (display-graphic-p) ;; (progn ;; (set-face-attribute 'default nil :font (format \"%s:pixelsize=%d\" \"Fira Code\" 19)) ;; 11 13 17 19 23 ;; ;; chinese font ;; (dolist (charset '(kana han symbol cjk-misc bopomofo)) ;; (set-fontset-font (frame-parameter nil 'font) ;; charset ;; (font-spec :family \"Sarasa Mono SC\")))) ;; 14 16 20 22 28 ;; )) ;; ;;(defun +my|init-font(frame) ;; (with-selected-frame frame ;; (if (display-graphic-p) ;; (+my/better-font)))) ;; ;;(if (and (fboundp 'daemonp) (daemonp)) ;; (add-hook 'after-make-frame-functions #'+my|init-font) ;; (+my/better-font)) ;; :weight 'semi-light) ;; doom-variable-pitch-font (font-spec :family \"sans\" :size 19)) ;;JetBrains Mono Medium,monospace ;; ;; There are two ways to load a theme. Both assume the theme is installed and ;; available. You can either set `doom-theme' or manually load a theme with the ;; `load-theme' function. This is the default: (setq doom-theme 'doom-one) ;; If you use `org' and don't want your org files in the default location below, ;; change `org-directory'. It must be set before org loads! (setq org-directory \"~/org/\") ;; This determines the style of line numbers in effect. If set to `nil', line ;; numbers are disabled. For relative line numbers, set this to `relative'. (setq display-line-numbers-type t) ;;;org-roam dir (setq org-roam-directory \"/home/du/Nutstore Files/Sync/org-mode/\") ;;;hungry-delete (require 'hungry-delete) (global-hungry-delete-mode) ;;;emacs cursor (setq evil-emacs-state-cursor '(\"red\" bar)) ;;; (setq confirm-kill-emacs nil) ;; default set to emacs model. (setq evil-default-state 'emacs) (after! org (setq evil-normal-state-modes nil)) ;; auto truncate-lines (set-default 'truncate-lines nil) ;; Here are some additional functions/macros that could help you configure Doom: ;; ;; - `load!' for loading external *.el files relative to this one ;; - `use-package!' for configuring packages ;; - `after!' for running code after a package has loaded ;; - `add-load-path!' for adding directories to the `load-path', relative to ;; this file. Emacs searches the `load-path' when you load packages with ;; `require' or `use-package'. ;; - `map!' for binding new keys ;; ;; To get information about any of these functions/macros, move the cursor over ;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k'). ;; This will open documentation for it, including demos of how they are used. ;; ;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how ;; they are implemented. ;; ;; FIXME Fix for emacs 27 ;; https://github.com/emacs-lsp/lsp-mode/issues/1778 ;;(setq lsp-gopls-codelens nil) ","date":"2020-11-04","objectID":"/doom-emacs-configure/:1:0","tags":["manjaro","doom-emacs"],"title":"doom-emacs的配置文件(LST)","uri":"/doom-emacs-configure/"},{"categories":["emacs"],"content":"init.el ;;; init.el -*- lexical-binding: t; -*- ;; This file controls what Doom modules are enabled and what order they load ;; in. Remember to run 'doom sync' after modifying it! ;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's ;; documentation. There you'll find a \"Module Index\" link where you'll find ;; a comprehensive list of Doom's modules and what flags they support. ;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or ;; 'C-c c k' for non-vim users) to view its documentation. This works on ;; flags as well (those symbols that start with a plus). ;; ;; Alternatively, press 'gd' (or 'C-c c d') on a module to browse its ;; directory (for easy access to its source code). (doom! :input ;;chinese ;;japanese ;;layout ; auie,ctsrnm is the superior home row :completion company ; the ultimate code completion backend ;;helm ; the *other* search engine for love and life ;;ido ; the other *other* search engine... ivy ; a search engine for love and life :ui ;;deft ; notational velocity for Emacs doom ; what makes DOOM look the way it does doom-dashboard ; a nifty splash screen for Emacs doom-quit ; DOOM quit-message prompts when you quit Emacs ;;fill-column ; a `fill-column' indicator hl-todo ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW ;;hydra ;;indent-guides ; highlighted indent columns ;;ligatures ; ligatures and symbols to make your code pretty again ;;minimap ; show a map of the code on the side modeline ; snazzy, Atom-inspired modeline, plus API ;;nav-flash ; blink cursor line after big motions ;;neotree ; a project drawer, like NERDTree for vim ophints ; highlight the region an operation acts on (popup +defaults) ; tame sudden yet inevitable temporary windows ;;tabs ; a tab bar for Emacs ;;treemacs ; a project drawer, like neotree but cooler ;;unicode ; extended unicode support for various languages vc-gutter ; vcs diff in the fringe vi-tilde-fringe ; fringe tildes to mark beyond EOB ;;window-select ; visually switch windows workspaces ; tab emulation, persistence \u0026 separate workspaces ;;zen ; distraction-free coding or writing :editor (evil +everywhere); come to the dark side, we have cookies file-templates ; auto-snippets for empty files fold ; (nigh) universal code folding ;;(format +onsave) ; automated prettiness ;;god ; run Emacs commands without modifier keys ;;lispy ; vim for lisp, for people who don't like vim ;;multiple-cursors ; editing in many places at once ;;objed ; text object editing for the innocent ;;parinfer ; turn lisp into python, sort of ;;rotate-text ; cycle region at point between text candidates snippets ; my elves. They type so I don't have to ;;word-wrap ; soft wrapping with language-aware indent :emacs dired ; making dired pretty [functional] electric ; smarter, keyword-based electric-indent ;;ibuffer ; interactive buffer management undo ; persistent, smarter undo for your inevitable mistakes vc ; version-control and Emacs, sitting in a tree :term eshell ; the elisp shell that works everywhere ;;shell ; simple shell REPL for Emacs ;;term ; basic terminal emulator for Emacs ;;vterm ; the best terminal emulation in Emacs :checkers syntax ; tasing you for every semicolon you forget ;;spell ; tasing you for misspelling mispelling ;;grammar ; tasing grammar mistake every you make :tools ;;ansible ;;debugger ; FIXME stepping through code, to help you add bugs ;;direnv ;;docker ;;editorconfig ; let someone else argue about tabs vs spaces ;;ein ; tame Jupyter notebooks with emacs (eval +overlay) ; run code, run (also, repls) ;;gist ; interacting with github gists lookup ; navigate your code and its documentation lsp magit ; a git porcelain for Emacs ;;make ; run make tasks from Emacs ;;pass ; password manager for nerds pdf ; pdf enhancements ;;prodigy ; FIXME managing external services \u0026 code builders ;;rgb ; creating color strings ;;taskrunner ; taskrunner for all your projects ;;terraform ; infrastructure as code ;;tmux ; an API for interacting wit","date":"2020-11-04","objectID":"/doom-emacs-configure/:2:0","tags":["manjaro","doom-emacs"],"title":"doom-emacs的配置文件(LST)","uri":"/doom-emacs-configure/"},{"categories":["emacs"],"content":"packages.el ;; -*- no-byte-compile: t; -*- ;;; $DOOMDIR/packages.el ;; To install a package with Doom you must declare them here and run 'doom sync' ;; on the command line, then restart Emacs for the changes to take effect -- or ;; use 'M-x doom/reload'. ;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror: ;(package! some-package) (package! hungry-delete) ;; To install a package directly from a remote git repo, you must specify a ;; `:recipe'. You'll find documentation on what `:recipe' accepts here: ;; https://github.com/raxod502/straight.el#the-recipe-format ;(package! another-package ; :recipe (:host github :repo \"username/repo\")) ;; If the package you are trying to install does not contain a PACKAGENAME.el ;; file, or is located in a subdirectory of the repo, you'll need to specify ;; `:files' in the `:recipe': ;(package! this-package ; :recipe (:host github :repo \"username/repo\" ; :files (\"some-file.el\" \"src/lisp/*.el\"))) ;; If you'd like to disable a package included with Doom, you can do so here ;; with the `:disable' property: ;(package! builtin-package :disable t) ;; You can override the recipe of a built in package without having to specify ;; all the properties for `:recipe'. These will inherit the rest of its recipe ;; from Doom or MELPA/ELPA/Emacsmirror: ;(package! builtin-package :recipe (:nonrecursive t)) ;(package! builtin-package-2 :recipe (:repo \"myfork/package\")) ;; Specify a `:branch' to install a package from a particular branch or tag. ;; This is required for some packages whose default branch isn't 'master' (which ;; our package manager can't deal with; see raxod502/straight.el#279) ;(package! builtin-package :recipe (:branch \"develop\")) ;; Use `:pin' to specify a particular commit to install. ;(package! builtin-package :pin \"1a2b3c4d5e\") ;; Doom's packages are pinned to a specific commit and updated from release to ;; release. The `unpin!' macro allows you to unpin single packages... ;(unpin! pinned-package) ;; ...or multiple packages ;(unpin! pinned-package another-pinned-package) ;; ...Or *all* packages (NOT RECOMMENDED; will likely break things) ;(unpin! t) ","date":"2020-11-04","objectID":"/doom-emacs-configure/:3:0","tags":["manjaro","doom-emacs"],"title":"doom-emacs的配置文件(LST)","uri":"/doom-emacs-configure/"},{"categories":["emacs"],"content":"custom.el (custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won't work right. '(package-selected-packages '(hungry-delete org-roam))) (custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won't work right. ) ","date":"2020-11-04","objectID":"/doom-emacs-configure/:4:0","tags":["manjaro","doom-emacs"],"title":"doom-emacs的配置文件(LST)","uri":"/doom-emacs-configure/"},{"categories":["LaTeX"],"content":"LaTeX_notes","date":"2020-10-18","objectID":"/latex/","tags":["LaTeX","Notes"],"title":"LaTeX_notes","uri":"/latex/"},{"categories":["LaTeX"],"content":"Notes in learnxtoy %为单行注释，无多行注释，命令以反斜线\\开始 设定文章字体大小: \\documentclass[12pt]{article} 定义所需库文件，展示数据要float和caption库，超链接要hyperref库 \\usepackage{caption} \\usepackage{float} \\usepackage{hyperref} 定义文件的属性 \\author{Zhangsan, Maliu, Wangwu} \\date{\\today} \\title{learn \\LaTeX \\hspace{1pt} notes} 正文内容 \\begin{document} %设定作者，时间，标题可以使用latex建立标题页 \\maketitle %分章节的时候可以建立目录 %编译文档两次保证顺序正确（？为什么编译两次。。。） %目录可以把文档分开 %使用\\newpage操作符 \\newpage \\table of contents \\newpage 摘要 %放在标题下或者文章主体上 %使用预定义的指令操作 \\begin{abstract} \\LaTeX \\hspace{1pt} documentation written as \\LaTeX! \\end{abstract} 章节 \\section{Introduction} Hello, my name is Wangwu. \\section{Another section} This is text for another section, the next is subsection. \\subsection{This is a subsection} Now this is a subsection. \\subsection{Pythagoras} Much better now. \\label{subsec:pythagoras} 章节编号 \\section*{This is an unnumbered section} % 不是所有的章节都要被标序号 \\section{Some Text notes} ","date":"2020-10-18","objectID":"/latex/:0:0","tags":["LaTeX","Notes"],"title":"LaTeX_notes","uri":"/latex/"},{"categories":["LaTeX"],"content":"未完待续…","date":"2020-10-18","objectID":"/latex/:1:0","tags":["LaTeX","Notes"],"title":"LaTeX_notes","uri":"/latex/"},{"categories":["Linux"],"content":"manjaro_kde关闭独立显卡","date":"2020-10-04","objectID":"/manjaro_kde_turnoff_gpu/","tags":["独立显卡","KDE"],"title":"manjaro_kde关闭独立显卡","uri":"/manjaro_kde_turnoff_gpu/"},{"categories":["Linux"],"content":"输入命令查看当前电脑中的显卡状态 lspci |grep -i vga 或者 lspci |grep -i NVIDIA //查看当前显卡状态或者英伟达显卡状态 rev ff表示关闭，需要将nvidia独立显卡设置为ff ","date":"2020-10-04","objectID":"/manjaro_kde_turnoff_gpu/:1:0","tags":["独立显卡","KDE"],"title":"manjaro_kde关闭独立显卡","uri":"/manjaro_kde_turnoff_gpu/"},{"categories":["Linux"],"content":"设置独立显卡为rev ff nvidia-setting可以选择关闭，但是我打开nvidia-setting没有关闭显卡的选项，可能是安装版本的问题。我在设置中查看本系统一直使用的是video-hybird-intel-nvidia-440xx-prime版本，先移除此驱动，再安装另一个版本的驱动程序，在hardware configuration选项中找到现在安装的驱动版本，右击选择移除此驱动。 安装video-hybird-intel-nvidia-430xx-bumblebee版本驱动,右击此驱动选择安装，等待安装完成，重启以后就会使用新的驱动，默认是关闭独立显卡的，可以通过命令查看 lspci |grep -i vga 或者 lspci |grep -i NVIDIA 显示nvidia rev ff，则代表独立显卡未启用。独立显卡的位置也就不再发热了。 ","date":"2020-10-04","objectID":"/manjaro_kde_turnoff_gpu/:2:0","tags":["独立显卡","KDE"],"title":"manjaro_kde关闭独立显卡","uri":"/manjaro_kde_turnoff_gpu/"},{"categories":["Golang"],"content":"Go语言基础-流程控制","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"if else写法: func main() { if 表达式1 { // { and 表达式1 same line 分支1 } else if 表达式2 { 分支2 } else { 分支3 } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举个例子: func main() { score := 65 if score \u003e= 90 { fmt.Println(\"A\") } else if score \u003e 75 { fmt.Println(\"B\") } else { fmt.Println(\"C\") } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:1","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"if 特殊写法 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举例： func ifDemo2() { if score := 65; score \u003e= 90 { fmt.Println(\"A\") } else if score \u003e 75 { fmt.Println(\"B\") } else { fmt.Println(\"C\") } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:1","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"for循环 基本格式: for 初始语句; 条件表达式; 结束语句 { 循环体语句 } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"例子1: func forDemo() { for i := 0; i \u003c 10; i++ { fmt.Println(i) } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:1","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"例子2: func forDemo2() { i := 0 for ; i \u003c 10; i++ { fmt.Println(i) } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:2","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"例子3: func forDemo3() { i := 0 for i \u003c 10 { fmt.Println(\"i\") i++ } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:3","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"无限循环例子: for { 循环体语句 } 可以通过break，goto，return，panic强制退出 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:4","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"for range(键值循环) go可以使用for range遍历数组、切片、字符串、map 及通道（channel） 数组、切片、字符串返回索引和值 map返回键和值 通道（channel）只返回通道内的值。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:4:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"switch case ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:5:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举例1: func swithDemo1() { finger := 3 switch finger { case 1: fmt.Println(\"大拇指\") case 2: fmt.Println(\"食指\") case 3: fmt.Println(\"中指\") case 4: fmt.Println(\"无名指\") case 5: fmt.Println(\"小拇指\") default: fmt.Println(\"无效的输入！\") } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:5:1","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举例2: func testSwitch3() { switch n := 7; n { case 1, 3, 5, 7, 9: fmt.Println(\"奇数\") case 2, 4, 6, 8: fmt.Println(\"偶数\") default: fmt.Println(n) } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:5:2","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举例3: func switchDemo4() { age := 30 switch { case age \u003c 25: fmt.Println(\"好好学习吧\") case age \u003e 25 \u0026\u0026 age \u003c 35: fmt.Println(\"好好工作吧\") case age \u003e 60: fmt.Println(\"好好享受吧\") default: fmt.Println(\"活着真好\") } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:5:3","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举例4: fallthrough语法可以执行满足条件的case的下一个case(若某个case满足执行了，后面跟个fallthrough则下一句也要执行)，是为了兼容C语言中的case设计的。 func switchDemo5() { s := \"a\" switch { case s == \"a\": fmt.Println(\"a\") fallthrough case s == \"b\": //这句也执行了 fmt.Println(\"b\") case s == \"c\": fmt.Println(\"c\") default: fmt.Println(\"...\") } } //结果为a b ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:5:4","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"goto(跳转到指定标签) break可以结束for、switch和select break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:6:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"举例: func breakDemo1() { BREAKDEMO1: for i := 0; i \u003c 10; i++ { for j := 0; j \u003c 10; j++ { if j == 2 { break BREAKDEMO1 } fmt.Printf(\"%v-%v\\n\", i, j) } } fmt.Println(\"...\") } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:6:1","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"continue(继续下次循环) continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。在 continue语句后添加标签时，表示开始标签对应的循环,举例: func continueDemo() { forloop1: for i := 0; i \u003c 5; i++ { // forloop2: for j := 0; j \u003c 5; j++ { if i == 2 \u0026\u0026 j == 2 { continue forloop1 } fmt.Printf(\"%v-%v\\n\", i, j) } } } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:7:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Golang"],"content":"References: 李文周的博客 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:8:0","tags":["Golang基础","Notes"],"title":"Go语言基础-流程控制","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Beancounts"],"content":"Beancounts复式记账","date":"2020-09-21","objectID":"/beancount/","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"Beancount ","date":"2020-09-21","objectID":"/beancount/:1:0","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"会计恒等式 Simple: Assets = Liabilities + Equity(Net Assets) 资产 = 负债 + 权益（净资产） ","date":"2020-09-21","objectID":"/beancount/:1:1","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"Beancount简介 Beancounts以账户为中心，除以上三部分再增加两个类别，收入和支出，既五个类别: Assets 资产 Liabilities 负债 Equity 权益（净资产） Expenses 支出 Income 收入 Beancount也可以自定义账户，以树形组织，例如: Assets:Cash:JPY Assets:Cash:USD Assets:Bank:CH:UBS Assets:Bank:CN:BoC Assets:Bank:US:Chase:Checking Assets:Bank:US:Chase:Saving Assets:Bank:JP:SMBC:JPY Assets:Bank:JP:SMBC:USD Assets:Broker:US:IB Assets:Points:Airline:JAL Assets:Points:Airline:United ","date":"2020-09-21","objectID":"/beancount/:1:2","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"Beancount简单语法介绍 必须声明开户时间，格式YYY-mm-dd 关键词open，定义当前日期开户 账户名称，格式用:隔开 货币种类(可以省略)，一般用三个字母，如美元、日元和人民币分别为\"USD\", “JPY”, “CNY” 2019-01-01 open Assets:Cash:JPY JPY 2019-01-01 open Assets:Cash:USD USD 2019-01-01 open Assets:Bank:CH:UBS CHF 2019-01-01 open Assets:Bank:CN:BoC CNY 2019-01-01 open Assets:Bank:US:Chase:Checking USD 2019-01-01 open Assets:Bank:US:Chase:Saving USD 2019-01-01 open Assets:Bank:JP:SMBC:JPY JPY 2019-01-01 open Assets:Bank:JP:SMBC:USD USD 2019-01-01 open Assets:Broker:US:IB USD, JPY, CHF 2019-01-01 open Assets:Points:Airline:JAL P_JAL 2019-01-01 open Assets:Points:Airline:United P_UA 负债类别账户，如信用卡，举例: 2019-01-01 open Liabilities:CreditCard:US:Discover USD 2019-01-01 open Liabilities:CreditCard:JP:Rakuten JPY 收入和支出类别也需要定义成一个账户，在语法上和资产、负债类的账户没有区别。举例: 2019-01-01 open Expenses:Clothing 2019-01-01 open Expenses:Food:Dinner 2019-01-01 open Expenses:Transport:Airline 2019-01-01 open Expenses:Transport:Railway 2019-01-01 open Income:Salary 2019-01-01 open Income:Rebate ","date":"2020-09-21","objectID":"/beancount/:1:3","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"基本借贷记账 复式记账又称为\"借贷记账\"，因为每条记录至少有一条借记(Debit)和一条贷记(Credit)，举例： 2019-01-01 * \"日本航空\" \"纽约-东京\" Expenses:Transport:Airline 1000 USD Liabilities:CreditCard:US:Discover -1000 USD 买了日本航空纽约-东京的机票，消费1000美元（贷记），付款的信用卡Discover扣款1000美元（借记）。 Beancount基本语法 YYYY-mm-dd * [\"payee\"] \"description\" posting 1 posting 2 ... 第一行包括日期， * 后是收款人payee(可选) 第二行开始以后每行要有两个缩进，包括帐户名、金额、货币，条目可以有多个 Notice:要保证所有的条目的总和为0，因为花的钱和账户减少的钱数额一定是相同的,如: 2019-01-01 * \"Walmart\" \"在超市买两件衣服和晚餐\" Expenses:Clothing 20 USD Expenses:Clothing 10 USD Expenses:Food:Dinner 10 USD Liabilities:CreditCard:US:Discover -40 USD 稍微复杂的例子: 2016-01-01 * \"Google\" \"工资\" Assets:Bank:US:Chase:Checking 500 USD Assets:Bank:US:Chase:Saving 1839.35 USD Assets:Pension:US:401k:PreTax 419.23 USD Assets:Pension:US:401k:PreTax 209.62 USD Expenses:Health:Insurance:Dental 3.14 USD Expenses:Finance:Insurance:TermLife 7.67 USD Expenses:Health:Insurance:Vision 0.98 USD Expenses:Tax:US:Federal 763.26 USD Expenses:Tax:US:Medicare 60.84 USD Expenses:Tax:US:SocialSecurity 260.15 USD Expenses:Tax:US:State:NY 212.59 USD Expenses:Tax:US:City:NYC 131.57 USD Expenses:Tax:US:State:NYDisability 1.2 USD Income:Salary:Regular -4192.31 USD Income:Allowance:TermLife -7.67 USD Income:Salary:401kMatch -209.62 USD 大多数的情况是一进一出两个账户，正负金额会记两遍，Beancount提供金额插值功能，即若总和为0，在有N个账户的时候，只需要声明N-1个账户的金额。则上述第一个例子中: 2019-01-01 * \"日本航空\" \"纽约-东京\" Expenses:Transport:Airline 1000 USD Liabilities:CreditCard:US:Discover Notice:在多个账户中需要写出每个的金额. 所有Expenses类别的账户都是正数，所有Income类别的账户都是负数.这是Beancount及类似工具使用正数来表示借记（Debit），负数表示贷记（Credit）的结果。同理通常Assets类是正数，Liabilities类是负数 ","date":"2020-09-21","objectID":"/beancount/:1:4","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"货币转换 哪怕不出国，只要是记录了非主要货币类资产，譬如投资品，代金券，航空公司里程，那么就需要货币转换。 工作货币 例如: option \"operating_currency\" \"JPY\" option \"operating_currency\" \"USD\" 定义了工作货币以后，在fava界面中可以看到工作货币单独列出的栏目。 Beancount货币转换的语法有两种，一种是使用@记录单位货币的转换价格，例如： 2019-01-01 * \"日本航空\" \"纽约-东京\" Expenses:Transport:Airline 1000 USD @ 110 JPY Liabilities:CreditCard:JP:Rakuten -110000 JPY 另一种方式更常用，使用@@记录转换后的总额： 2019-01-01 * \"日本航空\" \"纽约-东京\" Expenses:Transport:Airline 1000 USD @@ 110000 JPY Liabilities:CreditCard:JP:Rakuten -110000 JPY 货币转换不一定只在一个账户上。下面的这个例子是以每点2.5日元的价格，买了10000日本航空里程，但是付款的信用卡是以美元计价的，所以两遍都可以转换为25000日元来平衡。 2019-01-01 * \"日本航空\" \"购买里程\" Assets:Points:Airline:JAL 10000 P_JAL @ 2.5 JPY Liabilities:CreditCard:US:Discover -220.0 USD @@ 25000 JPY ","date":"2020-09-21","objectID":"/beancount/:1:5","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"借贷管理 复式记账的强大之处是每个账户都有状态，所有资金都可以操作 ","date":"2020-09-21","objectID":"/beancount/:1:6","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"未完待续… ","date":"2020-09-21","objectID":"/beancount/:1:7","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Beancounts"],"content":"参考文献： Beyond the void wzyboy’s blog blind with science ","date":"2020-09-21","objectID":"/beancount/:2:0","tags":["复式记账","Beancounts","fava","doom-emacs"],"title":"Beancounts","uri":"/beancount/"},{"categories":["Golang"],"content":"Go语言基础-运算符","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"1.算术运算符 运算符 描述 (+) 相加 (-) 相减 (*) 相乘 (/) 相除 (%) 求余 注意： ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"2.关系运算符 运算符 描述 (==) 检查两个值是否相等，如果相等返回 True 否则返回 False。 (!=) 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (\u003e) 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (\u003e=) 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (\u003c) 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (\u003c=) 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"3.逻辑运算符 运算符 描述 (\u0026\u0026) 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 (||) 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 (!) 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"4.位运算符 运算符 描述 (\u0026) 参与运算的两数各对应的二进位相与。（两位均为1才为1） (|) 参与运算的两数各对应的二进位相或。（两位有一个为1就为1） (^) 参与运算的两数各对应的二进位相异或,当两对应的二进位相异时,结果为1,(两位不一样则为1) (\u003c\u003c) 左移n位就是乘以2的n次方。“a\u003c\u003cb”是把a的各二进位全部左移b位，高位丢弃，低位补0。 (\u003e\u003e) 右移n位就是除以2的n次方。“a\u003e\u003eb”是把a的各二进位全部右移b位。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"5.赋值运算符 运算符 描述 (=) 简单的赋值运算符，将一个表达式的值赋给一个左值 (+=) 相加后再赋值 (-=) 相减后再赋值 (*=) 相乘后再赋值 (/=) 相除后再赋值 (%=) 求余后再赋值 (\u003c\u003c=) 左移后赋值 (\u003e\u003e=) 右移后赋值 (\u0026=) 按位与后赋值 (|=) 按位或后赋值 (^=) 按位异或后赋值 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"References: 李文周的博客 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["Golang基础","Notes"],"title":"Go语言基础-运算符","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Golang"],"content":"Go语言基础-基本数据类型","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"基本类型 除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。 整型分为以下两个大类：按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64 其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。 类型 描述 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"特殊整型: 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 notice: 使用int和uint时，考虑平台差异； 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或map的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint。 Go1.13版本之后引入了数字字面量语法： v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"不同进制数 借助fmt函数来将一个整数以不同进制形式展示： package main import \"fmt\" func main() { // 十进制 var a int = 10 fmt.Printf(\"%d \\n\", a) // 10 fmt.Printf(\"%b \\n\", a) // 1010 占位符%b表示二进制 // 八进制 以0开头 var b int = 077 fmt.Printf(\"%o \\n\", b) // 77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(\"%x \\n\", c) // ff fmt.Printf(\"%X \\n\", c) // FF } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"浮点数： float32和float64，float32最大范围3.4e38，可以使用常量定义：math.MaxFloat32。float64的浮点数的最大范围约为1.8e308，可以使用一个常量定义：math.MaxFloat64 打印浮点数：%f package main import ( \"fmt\" \"math\" ) func main(){ fmt.Printf(\"%f\\n\",math.Pi) fmt.Printf(\"%.2f\\n\",math.Pi)//只截取两位有效小数位 } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:1","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"复数: complex64和complex128 比如: var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:2","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"布尔值: bool只有true和false notice: 布尔类型变量的默认值为false。 Go语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:3","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"字符串: Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64等）一样。Go语言里的字符串的内部实现使用UTF-8编码。字符串的值为双引号(\")中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如： s1 := “hello” s2 := “你好” ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:4","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"字符串转义符: 转义符 含义 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 比如: fmt.Println(\"str := \\\"c:\\\\Code\\\\lesson1\\\\go.exe\\\"\") ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:5","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"多行字符串: Go语言中要定义一个多行字符串时，就必须使用反引号字符： s1 := `第一行 第二行 第三行 ` fmt.Println(s1) 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:6","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"字符串常用: 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join操作 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:7","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"byte and rune type: Go 语言的字符有以下两种： uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。 Go使用了特殊的rune类型来处理Unicode，让基于Unicode的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。 // 遍历字符串 func traversalString() { s := \"hello沙河\" for i := 0; i \u003c len(s); i++ { //byte fmt.Printf(\"%v(%c) \", s[i], s[i])//what is %v? } fmt.Println() for _, r := range s { //rune, for? fmt.Printf(\"%v(%c) \", r, r) } fmt.Println() } 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。 func changeString() { s1 := \"big\" // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = 'p' fmt.Println(string(byteS1)) s2 := \"白萝卜\" runeS2 := []rune(s2) runeS2[0] = '红' fmt.Println(string(runeS2)) } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:8","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"类型转换: Go语言中只有强制类型转换，没有隐式类型转换,强类型语法： T(表达式) 表达式包括变量、复杂算子和函数返回值等如 math包的Sqrt函数，接收float64类型，则需强制转换 func sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"References: 李文周的博客 ","date":"2020-09-21","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:5:0","tags":["Golang基础","Notes"],"title":"Go语言基础-基本数据类型","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Golang"],"content":"Go语言基础-变量和常量","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"变量和常量 25 keywords: | break | default | func | interface | select | | case | defer | go | map | struct | | chan | else | goto | package | switch | | const | fallthrough | if | range | type | | continue | for | import | return | var | 37 保留字: | constants: | true false iota nil | |------------+-------------------------------------------| | Types: | int int8 int16 int32 int64 | | | uint uint8 uint16 uint32 uint64 uintptr | | | float32 float64 complex128 complex64 | | | bool byte rune string error | |------------+-------------------------------------------| | Functions: | make len cap new append copy close delete | | | comlex real imag | | | panic recover | // ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:0:0","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"变量 data save to memory, if we want to find data, we should find it from memory,but its easy to find it if we save the address to a variy.so we find the var and we find the data. Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。 ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:0","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"声明变量: var 变量名 变量类型 no分号，如： var name string var age int var isOk bool ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:1","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"批量声明: package main import ( \"fmt\" ) func main() { var ( a string b int c bool d float32 ) } ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:2","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"变量初始化: int and float default is 0,string default is \"\",bool default is false,切片，函数，指针变量默认为nil 初始化标准格式: var 变量名 类型 = 表达式 比如: var name string = \"Du\" var age int = 18 or一次性初始化多个变量: var name,age = \"Du\",18 ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:3","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"类型推导，省略类型 var name = \"Du\" var age = 18 ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:4","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"短变量声明 := 声明并初始化变量,只能在函数内部使用 比如： package main import ( \"fmt\" ) var m = 100 //全局变量 func main() { n := 10 m := 200 //局部变量m fmt.Println(m, n) } ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:5","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"匿名变量 使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable),用_表示。比如: func foo()(int,string){ return 10, \"Du\" } func main(){ x,_ := foo() _,y := foo() fmt.Println(\"x=\",x) fmt.Println(\"y=\",y) } 在本例中foo函数返回两个值，但是输出时分两次每次输出一个值，则在调用foo函数的时候省略其中一个值，go中成为匿名变量，在lua等语言中，匿名变量也叫做哑元变量。 notice: 函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。 ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:1:6","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"常量 值不变，声明使用const，定义时必须赋值,声明后在整个程序运行期间值不再变化： const pi = 3.1415 const e = 2.7182 //多个变量一起声明： const( pi = 3.1415 e = 2.7182 ) //多个变量一起声明若省略值则和上面一行相同 const ( n1 = 100 n2 n3 )//n2,n3值为100 ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:2:0","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"iota 只在常量表达式中用的常量计数器 比如： //iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次 const( n1 = iota //const出现，iota为0 n2 //iota = 1 n3 //iota = 2 n4 //iota = 3 ) //使用_跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) //iota声明中间插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 //iota的应用: const( _ = iota //_ is 0 KB = 1 \u003c\u003c (10 * iota) MB = 1 \u003c\u003c (10 * iota) GB = 1 \u003c\u003c (10 * iota) TB = 1 \u003c\u003c (10 * iota) PB = 1 \u003c\u003c (10 * iota) ) //多个iota定义在一行: const( a,b = iota + 1, iota + 2 //1,2 c,d //2,3 e,f //3,4 ) ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:3:0","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["Golang"],"content":"References: 李文周的博客 ","date":"2020-09-20","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/:4:0","tags":["Golang基础","Notes"],"title":"Go语言基础-变量和常量","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"},{"categories":["随笔"],"content":"北京时间1977年9月5日20:56旅行者一号","date":"2020-09-08","objectID":"/earth/","tags":["随笔","Notes"],"title":"北京时间1977年9月5日20:56旅行者一号","uri":"/earth/"},{"categories":["随笔"],"content":" 旅行者一号43年的旅行，光行走20小时50分钟，近225亿千米 \" 旅行者一号 From this distant vantage point, the Earth might not seem of any particular interest. But for us, it’s different. Consider again that dot. That’s here. That’s home. That’s us. On it everyone you love, everyone you know, everyone you ever heard of, every human being who ever was, lived out their lives. The aggregate of our joy and suffering, thousands of confident religions, ideologies, and economic doctrines, every hunter and forager, every hero and coward, every creator and destroyer of civilization, every king and peasant, every young couple in love, every mother and father, hopeful child, inventor and explorer, every teacher of morals, every corrupt politician, every “superstar,” every “supreme leader,” every saint and sinner in the history of our species lived there– on a mote of dust suspended in a sunbeam. The Earth is a very small stage in a vast cosmic arena. Think of the rivers of blood spilled by all those generals and emperors so that in glory and triumph they could become the momentary masters of a fraction of a dot. Think of the endless cruelties visited by the inhabitants of one corner of this pixel on the scarcely distinguishable inhabitants of some other corner. How frequent their misunderstandings, how eager they are to kill one another, how fervent their hatreds. Our posturings, our imagined self-importance, the delusion that we have some privileged position in the universe, are challenged by this point of pale light. Our planet is a lonely speck in the great enveloping cosmic dark. In our obscurity– in all this vastness– there is no hint that help will come from elsewhere to save us from ourselves. The Earth is the only world known, so far, to harbor life. There is nowhere else, at least in the near future, to which our species could migrate. Visit, yes. Settle, not yet. Like it or not, for the moment, the Earth is where we make our stand. It has been said that astronomy is a humbling and character-building experience. There is perhaps no better demonstration of the folly of human conceits than this distant image of our tiny world. To me, it underscores our responsibility to deal more kindly with one another and to preserve and cherish the pale blue dot, the only home we’ve ever known. 中文翻译： 我们成功地（从外太空）拍到这张照片，细心再看，你会看见一个毫不出奇的小点。再看看那个光点，它就在这里。那是我们的家园，我们的一切。你所爱的每一个人，你认识的每一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生。我们的欢乐与痛苦聚集在一起，数以千计的自以为是的宗教、意识形态和经济学说，所有的猎人与强盗、英雄与懦夫、文明的缔造者与毁灭者、国王与农夫、年轻的情侣、母亲与父亲、满怀希望的孩子、发明家和探险家、德高望重的教师、腐败的政客、超级明星、最高领袖、人类历史上的每一个圣人与罪犯，都住在这里——一粒悬浮在阳光中的微尘。 在浩瀚的宇宙剧场里，地球只是一个极小的舞台。想想所有那些帝王将相杀戮得血流成河，他们的辉煌与胜利，曾让他们成为光点上一个部分的转眼即逝的主宰；想想栖身于这个点上的某个角落的居民，对别的角落几乎没有区别的居民所犯的无穷无尽的残暴罪行，他们的误解何其多也，他们多么急于互相残杀，他们的仇恨何其强烈。 我们的心情，我们的妄自尊大，我们在宇宙中拥有某种特权地位的错觉，都受到这个苍白光点的挑战。在庞大的包容一切的暗黑宇宙中，我们的行星是一个孤独的斑点。由于我们的低微地位和广阔无垠的空间，没有任何暗示，从别的什么地方会有救星来拯救我们脱离自己的处境。 有人说过，天文学令人感到自卑并能培养个性。除了这张从远处拍摄我们这个微小世界的照片，大概没有别的更好办法可以揭示人类妄自尊大是何等愚蠢。对我来说，这强调了我们有责任去更友好地相处，并且要保护和珍惜这个淡蓝色的光点——这是我们迄今所知的唯一家园。 ","date":"2020-09-08","objectID":"/earth/:0:0","tags":["随笔","Notes"],"title":"北京时间1977年9月5日20:56旅行者一号","uri":"/earth/"},{"categories":["Linux"],"content":"安装fctix5框架和rime输入法","date":"2020-09-05","objectID":"/fcitx5/","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"1. manjaro安装fctix5框架 ","date":"2020-09-05","objectID":"/fcitx5/:0:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"1.1 卸载原有的fctix4框架 sudo pacman -Rc fcitx ","date":"2020-09-05","objectID":"/fcitx5/:1:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"1.2 安装fctix5和中文词典 sudo pacman -S fcitx5-git fcitx5-chinese-addons-git fcitx5-chewing fcitx5-pinyin-zhwiki fcitx5-pinyin-moegirl fcitx5-configtool fcitx5-gtk-git fcitx5-qt4-git fcitx5-qt5-git 配置环境变量，若使用的为kde等桌面环境，需要在 ~/.xprofile 写入: export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\"@im=fcitx5\" export LANG=\"zh_CN.UTF-8\" export LC_CTYPE=\"zh_CN.UTF-8\" 若使用到为gnome桌面环境，则在~/.bashrc或者~/.zshrc或者/etc/environment中添加上述内容，然后source ~/.zshrc 后重启fcitx5生效。 2. 安装rime输入法 ","date":"2020-09-05","objectID":"/fcitx5/:2:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"2.1 安装rime sudo pacman -S fcitx5-rime ","date":"2020-09-05","objectID":"/fcitx5/:3:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"2.2 设置自启动(可以不设置) sudo cp /usr/share/applications/fcitx5.desktop /etc/xdg/autostart 3. 配置 ","date":"2020-09-05","objectID":"/fcitx5/:4:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"3.1 配置默认输入法 右击小键盘图标，点击配置，在增加输入法选项中，输入rime查找，双击rime添加到输入法中， 右击小键盘选择重新启动fcitx5后，按ctrl+space或者ctrl+shift切换输入法，稍等片刻中州韵rime设置成功。 ","date":"2020-09-05","objectID":"/fcitx5/:5:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"3.2 配置定制输入法(四叶草) ","date":"2020-09-05","objectID":"/fcitx5/:6:0","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"3.2.1 安装四叶草 yay -S rime-cloverpinyin 未安装yay的用户请先安装yay sudo pacman -S yay ","date":"2020-09-05","objectID":"/fcitx5/:6:1","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"3.2.2 配置四叶草 切换到配置文件夹: cd ~/.local/share/fcitx5/rime 创建新文件: sudo nano default.custom.yaml 内容为: patch: \"menu/page_size\": 8 schema_list: - schema: clover “menu/page_size”: 8 表示打字时输入面板每一页的候选词数目，可以设置成 1~9 任意数字。写好之后，点击右下角托盘图标右键菜单，点“重新部署”，然后再切换到rime，右击查看方案列表，应该就有“四叶草拼音输入法”的选项了，如果没有请多尝试几次，或者等1分钟左右重新启动fcitx5. ","date":"2020-09-05","objectID":"/fcitx5/:6:2","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"3.2.3 安装词频词组(借用ayamir老哥的配置) ([下载链接](dict.7z - Nutstore - Cloud Storage|Cloud Disk|Network Disk|Synchronous|Backup|Unlimited Space|Free Network Hard Disk|Dropbox|Box|Onedrive|Google Drive)) 将下载好的文件解压到 ~/.local/share/fcitx5/rime 里面，重启fcitx5即可。 说明：四叶草配置中\"帧\"这个字需要使用zheng才能打出来，修改为zhen的方法为: sudo vim /usr/share/rime-data/clover.base.dict.yaml 编辑此文件，在第2570行处，将zheng改为zhen 虐待的虐使用nve才能打出来 ","date":"2020-09-05","objectID":"/fcitx5/:6:3","tags":["rime","fctix5"],"title":"安装fctix5框架和rime输入法","uri":"/fcitx5/"},{"categories":["Linux"],"content":"ffmpeg处理音频和视频","date":"2020-09-05","objectID":"/ffmpeg/","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"(2020年11月19日更新，增加3,4和一些注释) (2020年11月25日更新，增加preface，增加5,6,7关于GIF的一些操作) (2022年05月05日更新，add video code detect and code convert) ","date":"2020-09-05","objectID":"/ffmpeg/:0:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"Preface 以下所有操作需要安装ffmpeg和imagemagick软件，在manjaro或者arch中可以使用: sudo pacman -S ffmpeg imagemagick ","date":"2020-09-05","objectID":"/ffmpeg/:1:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"1. ffmpeg从视频中提取音频： ffmpeg -i input.mp4 -f mp3 -vn output.mp3 # -i: input file # -f: format # -vn: video not ","date":"2020-09-05","objectID":"/ffmpeg/:2:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"2. ffmpeg截取音频： 如果我想把aa.mp3中的1分12秒到1分42秒的地方切出来，然后存成bb.mp3，指令如下： ffmpeg -i aa.mp3 -ss 00:01:12 -t 00:00:30 -acodec copy bb.mp3 # 从1分12秒开始一直到30秒后的位置。 ","date":"2020-09-05","objectID":"/ffmpeg/:3:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"3. ffmpeg转换格式flac到mp3 ffmpeg -i input.flac -b:a 192k -acodec mp3 -ar 44100 -ac 2 output.mp3 ","date":"2020-09-05","objectID":"/ffmpeg/:4:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"4. ffmpeg把多张图片制作成视频 ffmpeg -r:v 1/5 -i \"%05d.png\" -r:v 30 -codec:v libx264 -preset veryslow -pix_fmt yuv420p -crf 28 -an \"filename.mp4\" # 制作一个每张图片显示5s，视频侦数为30FPS的视频 ","date":"2020-09-05","objectID":"/ffmpeg/:5:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"5. ffmpeg从视频中截取gif ffmpeg -ss 00:00:20 -i input.mp4 -to 10 -r 10 -vf scale=200:-1 output.gif # -ss:截取起点 # -i:输入的视频文件 # -to: 截取终点 # -r:帧速率，值越大GIF文件质量越高 # -vf: GIF的缩放大小 ","date":"2020-09-05","objectID":"/ffmpeg/:6:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"6. 合并GIF文件 convert -delay 120 -loop 0 input.gif output.gif # -delay:GIF播放速度 # -loop 0:无限循环 ","date":"2020-09-05","objectID":"/ffmpeg/:7:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"7. 从JPG图片创建GIF动画 convert -delay 120 -loop 0 input.jpg output.gif # -delay:GIF播放速度 # -loop 0:无限循环 ","date":"2020-09-05","objectID":"/ffmpeg/:8:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"8. 查看视频的编码格式 ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 source.mp4 # 常见的编码格式有: # h.265(HEVC) # h.264(AVC) ","date":"2020-09-05","objectID":"/ffmpeg/:9:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"9. 视频编码转换 ffmpeg -i source.mp4 -c:v h264 -c:a copy output.mp4 #将源文件source.mp4转换为h264编码的output.mp4文件 # -c:v -copy:video # -c:a -copy:audio ","date":"2020-09-05","objectID":"/ffmpeg/:10:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"未完待续…","date":"2020-09-05","objectID":"/ffmpeg/:11:0","tags":["video\u0026music","ffmpeg"],"title":"ffmpeg处理音频和视频","uri":"/ffmpeg/"},{"categories":["Linux"],"content":"manjaro清理磁盘和换源","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"清理 ","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/:1:0","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"1.清理无用的依赖包: sudo pacman -R $(pacman -Qdtq) ","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/:1:1","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"2.清理下载的缓存(安装包): sudo pacman -Scc yay -Scc ","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/:1:2","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"3.清理日志文件: sudo journalctl –vacuum-size=50M ","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/:1:3","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"换源 ","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/:2:0","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"切换到中国的镜像 sudo pacman-mirrors -i -c China -m rank //选择合适的一个即可 ","date":"2020-08-03","objectID":"/manjaro%E6%B8%85%E7%90%86/:2:1","tags":["Notes"],"title":"manjaro清理磁盘和换源","uri":"/manjaro%E6%B8%85%E7%90%86/"},{"categories":["Linux"],"content":"linux下的一些Tips","date":"2020-08-02","objectID":"/problems-set/","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"1.wget使用代理: wget /**文件链接**/ -e use_proxy=yes -e http_proxy=127.0.0.1:port ","date":"2020-08-02","objectID":"/problems-set/:1:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"2.linux下查看硬盘信息: lsblk # list block or sudo hdparm -i/I /dev/sd* ","date":"2020-08-02","objectID":"/problems-set/:2:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"3.查看系统安装时间(linux): ls -lact --full-time /etc | tail -1 | awk '{print $6,$7}' ","date":"2020-08-02","objectID":"/problems-set/:3:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"4.get weather: curl wttr.in/qingdao #获取青岛天气 curl v2d.wttr.in/qingdao 访问 wttr 可以查看更多其他有趣的命令 ","date":"2020-08-02","objectID":"/problems-set/:4:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"5.change JDK version: archlinux-java help archlinux-java status sudo archlinux-java set java-12-jdk ","date":"2020-08-02","objectID":"/problems-set/:5:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"6.linux unzip 乱码解决: 6.1 使用unzip命令(建议) unzip -O GBK/cp936 *zip #-O为指定解压缩的字符集编码 windows默认的字符集为GBK 6.2 使用unar命令(不建议) unar sth.zip #invalid ","date":"2020-08-02","objectID":"/problems-set/:6:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"7.node_modules检查及更新 npm install npm-check -g npm-check # npm-check compare with package.json to check update or new install update package: npm update -S npm update -D ","date":"2020-08-02","objectID":"/problems-set/:7:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"8.linux百度云打开后一直缓冲无法显示登录界面解决办法： cd ~/.local/share/baidu/baidunetdisk rm baidunetdiskdata.db or rm ~/.local/share/baidu/baidunetdisk/baidunetdiskdata.db ","date":"2020-08-02","objectID":"/problems-set/:8:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"9.git push origin master报错原因可能是空文件夹未初始化： touch readme #工程文件介绍 git add . #加入文件 git commit -m 'add' #修改部分描述 git push origin master #推到github 若报错则先pull一下 git pull origin master #拉取云端文件 ","date":"2020-08-02","objectID":"/problems-set/:9:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Linux"],"content":"10.SS subscribe(可用或不可用概不负责) https://raw.githubusercontent.com/ssrsub/ssr/master/ssrsub https://qiaomenzhuanfx.netlify.com/ https://muma16fx.netlify.com/ https://raw.githubusercontent.com/voken100g/AutoSSR/master/online https://raw.githubusercontent.com/voken100g/AutoSSR/master/recent https://youlianboshi.netlify.com/ https://yzzz.ml/freessr/ https://desperadoj.com/sub/ss.html http://ss.pythonic.life/subscribe 未完待续… ","date":"2020-08-02","objectID":"/problems-set/:10:0","tags":["Notes"],"title":"linux下的一些Tips","uri":"/problems-set/"},{"categories":["Blog"],"content":"配置hexo博客出错的问题及解决办法","date":"2020-05-19","objectID":"/hexo_wrong/","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"执行: hexo deploy ","date":"2020-05-19","objectID":"/hexo_wrong/:1:0","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"报错: FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html TypeError [ERR_INVALID_ARG_TYPE]: The \"mode\" argument must be integer. Received an instance of Object at copyFile (fs.js:1890:10) at tryCatcher (/home/du/nswy123/node_modules/bluebird/js/release/util.js:16:23) at ret (eval at makeNodePromisifiedEval (/usr/lib/node_modules/hexo/node_modules/bluebird/js/release/promisify.js:184:12), \u003canonymous\u003e:13:39) at /home/du/nswy123/node_modules/hexo-fs/lib/fs.js:144:39 at tryCatcher (/home/du/nswy123/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/home/du/nswy123/node_modules/bluebird/js/release/promise.js:547:31) at Promise._settlePromise (/home/du/nswy123/node_modules/bluebird/js/release/promise.js:604:18) ... ","date":"2020-05-19","objectID":"/hexo_wrong/:2:0","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"解决方法: 此问题是因为升级nodejs后导致的，查找相关资料,发现同样的问题，解决方法就是降级nodejs，本机为manjaro系统，nodejs已经升级为14.2.0,使用pacman作为包管理器，因此降级的方法有以下几种。 (17 July, 2020 update, suggest first method, and manjaro still have the question, I think the question exist have a long time, now node version is 14.3.0, method number 1 still work.) ","date":"2020-05-19","objectID":"/hexo_wrong/:3:0","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"1、(建议)降低版本 用node的版本管理器nvm，将其设置为低版本。 sudo pacman -S nvm # nvm: node version manage install nvm use --delete-prefix v12.16.3 # set node version ","date":"2020-05-19","objectID":"/hexo_wrong/:3:1","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"2、(不建议)离线安装 在这里找到nodejs的12.16.3版本，或者目前lst的lastest，下载后使用pacman安装，比如: sudo pacman -U \"files\" 此方法我没有成功，显示缺少medata，可能是因为依赖的关系。 ","date":"2020-05-19","objectID":"/hexo_wrong/:3:2","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"3、(不建议)使用downgrade包进行管理: sudo pacman -S downgrade downgrade nodejs 此方法我又失败了，以降级firefox为例，具体为: downgrade firefox 报错: Downgrading from A.L.A. is disabled on the stable branch. To override this behavior, set DOWNGRADE_FROM_ALA to 1 . See https://wiki.manjaro.org/index.php?title=Using_Downgrade for more details. Unable to downgrade firefox 按照提示输入: DOWNGRADE_FROM_ALA = 1 依然无用. ","date":"2020-05-19","objectID":"/hexo_wrong/:3:3","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["Blog"],"content":"再次执行: hexo d 又一次报错: ERROR Plugin load failed: hexo-directory-category TypeError: rule must be a function, a string or a regular expression. at new Pattern (/Users/me/wiki-site/node_modules/hexo/node_modules/hexo-util/lib/pattern.js:17:11) 查阅hfkstackoverflow,使用yarn来管理包: # 移除包 yarn remove hexo-directory-category # 添加包 yarn add hexo-directory-category -S 再次输入: hexo d 第三次报错: INFO Deploying: git INFO Clearing .deploy_git folder... FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Error: EACCES: permission denied, unlink '/home/du/nswy123/.deploy_git/archives/index.html' 显然是因为权限不够的原因， 可以直接： sudo hexo d 或者，查看报错文件夹的权限: ls ~/nswy123/.deploy_git -al 输出: total 36 drwxr-xr-x 9 du du 4096 5月 19 18:23 . drwxr-xr-x 8 du du 4096 5月 19 18:22 .. drwxr-xr-x 5 root root 4096 5月 19 18:21 2020 drwxr-xr-x 3 root root 4096 5月 19 18:21 archives drwxr-xr-x 4 root root 4096 5月 19 18:21 assets drwxr-xr-x 2 root root 4096 5月 19 18:21 fonts drwxr-xr-x 8 du du 4096 5月 19 18:21 .git drwxr-xr-x 2 root root 4096 5月 19 18:21 img drwxr-xr-x 13 root root 4096 5月 19 18:21 tags 为了确保权限足够，添加权限: sudo chmod -R 777 ~/nswy123/.deploy_git 大家可以根据自己的情况选择 777 or 755 再次执行命令: hexo d 输入github账户名和密码 成功推送 ","date":"2020-05-19","objectID":"/hexo_wrong/:3:4","tags":["hexo","nodejs","blog"],"title":"配置hexo博客出错的问题及解决办法","uri":"/hexo_wrong/"},{"categories":["emacs"],"content":"spacemacs block cursor change to I-beam, and themes install","date":"2020-05-18","objectID":"/block_to_i-beam/","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["emacs"],"content":"(20,July 2020 update， NOTICE: spacemacs is develop) (03,Aug 2020 update， Add how install themes) ","date":"2020-05-18","objectID":"/block_to_i-beam/:0:0","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["emacs"],"content":"1、Change cursor open .spacemacs file: sudo nano ~/.spacemacs use “ctrl+w” open search，input “user-config” to find the position，and add: (setq evil-emacs-state-cursor '(\"red\" bar)) Look like: restart spacemacs。 ","date":"2020-05-18","objectID":"/block_to_i-beam/:1:0","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["emacs"],"content":"2、Add themes install a package include many themes open .spacemacs and find that: (defun dotspacemacs/layers () ","date":"2020-05-18","objectID":"/block_to_i-beam/:2:0","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["emacs"],"content":"Add a package themes-megapack looks like(in the end): then you can use “alt+x”, input “load-theme”, choose a theme, I think “ujelly” is best for me, because it can protect my eyes. ","date":"2020-05-18","objectID":"/block_to_i-beam/:2:1","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["emacs"],"content":"Reference: A community-driven Emacs distribution ","date":"2020-05-18","objectID":"/block_to_i-beam/:3:0","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["emacs"],"content":"Pictures: ","date":"2020-05-18","objectID":"/block_to_i-beam/:4:0","tags":["manjaro","spacemacs"],"title":"spacemacs block cursor change to I-beam, and themes install","uri":"/block_to_i-beam/"},{"categories":["Linux"],"content":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","date":"2020-03-23","objectID":"/manjaro-stuck/","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"1、安装 刻录软件：rufus，刻录模式建议选择dd ","date":"2020-03-23","objectID":"/manjaro-stuck/:1:0","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"2、遇到的问题(安装时卡住) Started TLP system startup/shutdown A start job is running for livemedia mhwd scripe(xxxx) ","date":"2020-03-23","objectID":"/manjaro-stuck/:2:0","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"2.1 解决方法 引导开机后进入安装启动界面，选择BOOT栏 按e键进入编辑模式，将driver=free改成driver=intel 在后面加上xdriver=mesa acpi_osi=! acpi_osi=“Windows 2009” 按ctrl+x或F10启动 此时可以进入安装界面，可参考其他教程按自己所需进行分区，我个人一般不分配/home空间，直接大部分给/，即根目录，swap分区因为笔记本16g的内存，我会给到8g，这个看个人情况，/boot启动分区最为重要，一定要记住盘区/sd*，将其设置为启动引导分区，切勿选错。 ","date":"2020-03-23","objectID":"/manjaro-stuck/:2:1","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"2.2 分区安装完成以后，重启依然会黑屏，解决方法 启动进入grub引导界面，默认即Manjaro选项卡，在此选项卡按e进入编辑页面，在倒数第二行找到quite，在其后添加 acpi_osi=! acpi_osi=‘Windows 2009’ 然后按F10进入系统，进入系统修改启动文件grub.cfg来彻底解决黑屏问题。 打开终端，输入 sudo nano /boot/grub/grub.cfg 如果没有安装nano可以使用vim或者vi打开 sudo vim /boot/grub/grub.cfg sudo vi /boot/grub/grub.cfg 打开后找到linux /boot/vmlinuz-5.4-x86_64 root=UUID=a9b1b419-f272-4f3c-90ae-30c57807cb1e rw quiet这一行(可以直接使用查找快捷键，ctrl+w，输入quiet，直接定位到quiet的位置)，不同linux版本可能有一些差别，在quiet后面添加xdriver=mesa acpi_osi=! acpi_osi=“Windows 2009”即可,按ctrl+o(字母)提示保存，再按回车，然后按ctrl+x退出。 ","date":"2020-03-23","objectID":"/manjaro-stuck/:2:2","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"3、配置pacman源 sudo pacman-mirrors -i -c China -m rank 在弹出的窗口选择合适的来使用 ","date":"2020-03-23","objectID":"/manjaro-stuck/:3:0","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"4、配置archlinuxcn源 sudo nano /etc/pacman.conf 在末尾添加以下内容： [archlinuxcn] SigLevel = Optional TrustedOnly Server = http://repo.archlinuxcn.org/$arch 之后执行： sudo pacman-mirrors -g #更新 sudo pacman -Syyu #更新系统 sudo pacman -S archlinuxcn-keyring #导入keyring ","date":"2020-03-23","objectID":"/manjaro-stuck/:4:0","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"5、设置代理 目前比较稳定的如v2ray和trojan windows端建议使用v2rayN-Release，打开后选择v2rayN-Core.zip下载，鉴于国内下载速度比较慢，点击从坚果云(3.19版本)下载。(注:坚果云需要注册才能使用) linux(manjaro\u0026archlinux)端的GUI软件推荐trojan和qv2ray,qv2ray核心用的v2ray,点击跳转到qv2ray的下载地址或者直接使用命令安装： sudo pacman -S v2ray qv2ray trojan的安装方法 sudo pacman -S trojan trojan安装完后需要配置一下，详情看下面说明。(20, July 2020 update, qv2ray has developed a plugin for trojan, so you just to use qv2ray.) mac端使用clashx或者qv2ray,clashx在mac端使用方法比较简单，现在先鸽一下，有空再写。 5.1 配置qv2ray qv2ray图形界面比较容易操作，根据机场提供的订阅地址输入后即可以代理。如图，点击左上角订阅，然后输入订阅地址既可。具体可以参考wiki,(20,July 2020 update,qv2ray have a new version, and it has complished very well, please try to update it.) 5.2 配置trojan sudo nano /etc/trojan/config.json 打开配置文件后只需要更改以下几个选项 \"run_type\": \"client\", \"local_addr\": \"127.0.0.1\", //此为本地地址 \"local_port\": 1080, //设置端口，可根据自己需要更改 \"remote_addr\": \"此地址由机场提供\",//机场提供的地址 \"remote_port\": 443, // 机场提供的端口 \"password\": [ \"input password\" //机场提供的密码 设置完毕后按ctrl+o(字母)提示保存，再按回车，按ctrl+x退出 ","date":"2020-03-23","objectID":"/manjaro-stuck/:5:0","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"6、推荐的机场 (20, July 2020 update)我目前在用的机场，机场用的v2ray协议，现在还算稳定，速度每个时间段不同，(我是第1组进的，1组现在不限速好像，设备可以用3个，不过现在已经分成好几个组了，速度跟一开始没法比，但我个人认为自己用还是绰绰有余，家用宽带为200m，youtube没有卡过)，价格也还可以，有一个1元的两天套餐可以先体验，我个人认为比较合适的套餐: 128g/mon:季付38,年付88(My choose); 256g/mon:年付128; 还有其他的套餐可以去网站注册后自行查看，我个人认为上面两个套餐选哪个都够用了，我一个月大概才用10-20g流量，远远足够，不过每个人可以根据自己的需求使用，点击链接进行注册，祝大家用的愉快。 (03, Oct 2020 update)布丁跑路了~太惨了，我还有一年多的流量没用，这波促销后携款跑路是真的骚。大家还是尽量使用大机场吧！我目前使用的是之前 买的搬瓦工洛杉矶cn线路vps，大概是17年买的，还是18刀左右一年，自己先搭了一个v2ray使用，速度还可以，网上有一键安装的脚本，安装还是很方便的，就是怕ip被封禁，换个ip大概三分之一的套餐的价格了，实在不值得，等改日再写一下。目前还是推荐的搬瓦工自己的机场，JustMySocks，可以无限换ip不怕被墙，目前套餐最便宜的好像是美国地区一年400人民币，有需要的人可以先考虑此方案，还有有一个美国地区一年一百多的套餐售罄，等上货了再入手。目前先这样，最近作业有些多，好不容易有个几天假期，我又折腾了一波路由器，今天总算折腾完了，软路由刷了eSir的GDQ版，好是好就是小主机功率有点高，先束之高阁吧，k2p本来打算做ap，但是不上软路由，k2p就当主力了，今天刷了breed用的官改版，本来想继续试一试老毛子的固件，折腾的太晚了，又和同学聊了会天，就先搁置吧，毕竟刷了breed就不怕成砖了，这一段时间先静一下心，过完这个国庆节，希望这学期能够有所收获。 ","date":"2020-03-23","objectID":"/manjaro-stuck/:6:0","tags":["Manjaro","独立显卡","机场"],"title":"Manjaro显卡驱动问题开机黑屏，配置源，机场etc","uri":"/manjaro-stuck/"},{"categories":["Linux"],"content":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","date":"2020-03-08","objectID":"/baloo_file/","tags":["KDE","manjaro"],"title":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","uri":"/baloo_file/"},{"categories":["Linux"],"content":"查看进程 使用htop命令或top命令查看进程，发现 baloo_file_extractor 这个程序占用cpu很高，笔记本风扇持续不断运行，google一下发现这个问题在KDE在4.13版本的时候就有了，具体可以查看这个帖子 ","date":"2020-03-08","objectID":"/baloo_file/:1:0","tags":["KDE","manjaro"],"title":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","uri":"/baloo_file/"},{"categories":["Linux"],"content":"这个程序的作用: framework for searching and managing metadata，在文件搜索时建立文件索引 ","date":"2020-03-08","objectID":"/baloo_file/:2:0","tags":["KDE","manjaro"],"title":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","uri":"/baloo_file/"},{"categories":["Linux"],"content":"解决办法: 2022-3-15 update. Best method: balooctl disable 把 baloo_file 和 baloo_file_extractor 这两个文件备份，然后建立一个到 /bin/true 的链接 ","date":"2020-03-08","objectID":"/baloo_file/:3:0","tags":["KDE","manjaro"],"title":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","uri":"/baloo_file/"},{"categories":["Linux"],"content":"依次执行以下命令: sudo mv /usr/bin/baloo_file_extractor /usr/bin/baloo_file_extractor.bak sudo ln -s /bin/true /usr/bin/baloo_file_extractor sudo mv /usr/bin/baloo_file /usr/bin/baloo_file.bak sudo ln -s /bin/true /usr/bin/baloo_file 然后重启电脑即可 ","date":"2020-03-08","objectID":"/baloo_file/:3:1","tags":["KDE","manjaro"],"title":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","uri":"/baloo_file/"},{"categories":["Linux"],"content":"相关链接： https://blog.csdn.net/kongxx/article/details/78809716 https://www.whatled.com/post-1594.html ","date":"2020-03-08","objectID":"/baloo_file/:4:0","tags":["KDE","manjaro"],"title":"KDE开机baloo_file_extractor占用cpu过高导致卡顿问题","uri":"/baloo_file/"},{"categories":["Linux"],"content":"latte-dock 更新到0.9.9 右击dock栏无法打开设置","date":"2020-03-03","objectID":"/latte-dock/","tags":["latte","dock"],"title":"latte-dock 更新到0.9.9 右击dock栏无法打开设置","uri":"/latte-dock/"},{"categories":["Linux"],"content":"2020年3月7日更新：latte-dock已经修复这个问题,此文留作参考 ","date":"2020-03-03","objectID":"/latte-dock/:0:0","tags":["latte","dock"],"title":"latte-dock 更新到0.9.9 右击dock栏无法打开设置","uri":"/latte-dock/"},{"categories":["Linux"],"content":"系统配置 ","date":"2020-03-03","objectID":"/latte-dock/:1:0","tags":["latte","dock"],"title":"latte-dock 更新到0.9.9 右击dock栏无法打开设置","uri":"/latte-dock/"},{"categories":["Linux"],"content":"latte-dock 0.9.9的更新内容 Version 0.9.9 * CRITICAL: initialize properly configuration files during startup [kde#417886] * IMPORTANT: Do not load a Shared Layout as Central when it is already loaded and as such do not mess the MultipleLayouts appearance when a Shared layout should also be used [kde#417886] * [wayland] do not crash when right clicking Tasks plasmoid [kde#417546] * update animations speed to support plasma 5.18 new animation speed values * do not double release dock visibility after Meta application launcher triggering [kde#417239] * improve blur region calculations in general and do not send invalid areas to kwin [kde#417254] * improve blur area calculations during startup when parabolic effect is disabled [kde#416928] * show Tasks icon size properly during startup when parabolic effect is disabled 我有试过按住ctrl+右击，alt+右击，shift+右击dock，虽然有响应但是无法选择设置选项。google发现这个帖子 贴一下关键评论: 直接用快捷键就可以打开了，Win + a 如果你有多个latte-dock的话，一般是默认打开第一个dock ","date":"2020-03-03","objectID":"/latte-dock/:2:0","tags":["latte","dock"],"title":"latte-dock 更新到0.9.9 右击dock栏无法打开设置","uri":"/latte-dock/"},{"categories":["Notes"],"content":"Markdown For Typora","date":"2020-02-20","objectID":"/markdown-reference/","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Overview Markdown is created by Daring Fireball; the original guideline is here. Its syntax, however, varies between different parsers or editors. Typora is using GitHub Flavored Markdown. ","date":"2020-02-20","objectID":"/markdown-reference/:1:0","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Block Elements ","date":"2020-02-20","objectID":"/markdown-reference/:2:0","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Paragraph and line breaks A paragraph is simply one or more consecutive lines of text. In markdown source code, paragraphs are separated by two or more blank lines. In Typora, you only need one blank line (press Return once) to create a new paragraph. Press Shift + Return to create a single line break. Most other markdown parsers will ignore single line breaks, so in order to make other markdown parsers recognize your line break, you can leave two spaces at the end of the line, or insert \u003cbr/\u003e. ","date":"2020-02-20","objectID":"/markdown-reference/:2:1","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Headers Headers use 1-6 hash (#) characters at the start of the line, corresponding to header levels 1-6. For example: # This is an H1 ## This is an H2 ###### This is an H6 In Typora, input ‘#’s followed by title content, and press Return key will create a header. ","date":"2020-02-20","objectID":"/markdown-reference/:2:2","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Blockquotes Markdown uses email-style \u003e characters for block quoting. They are presented as: \u003e This is a blockquote with two paragraphs. This is first paragraph. \u003e \u003e This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. \u003e This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. In Typora, inputting ‘\u003e’ followed by your quote contents will generate a quote block. Typora will insert a proper ‘\u003e’ or line break for you. Nested block quotes (a block quote inside another block quote) by adding additional levels of ‘\u003e’. ","date":"2020-02-20","objectID":"/markdown-reference/:2:3","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Lists Input * list item 1 will create an unordered list - the * symbol can be replace with + or -. Input 1. list item 1 will create an ordered list - their markdown source code is as follows: ## un-ordered list * Red * Green * Blue ## ordered list 1. Red 2. Green 3. Blue ","date":"2020-02-20","objectID":"/markdown-reference/:2:4","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Task List Task lists are lists with items marked as either [ ] or [x] (incomplete or complete). For example: - [ ] a task list item - [ ] list syntax required - [ ] normal **formatting**, @mentions, #1234 refs - [ ] incomplete - [x] completed You can change the complete/incomplete state by clicking on the checkbox before the item. ","date":"2020-02-20","objectID":"/markdown-reference/:2:5","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"(Fenced) Code Blocks Typora only supports fences in GitHub Flavored Markdown. Original code blocks in markdown are not supported. Using fences is easy: Input ``` and press return. Add an optional language identifier after ``` and we’ll run it through syntax highlighting: Here's an example: ​``` function test() { console.log(\"notice the blank line before this function?\"); } ​``` syntax highlighting: ​```ruby require 'redcarpet' markdown = Redcarpet.new(\"Hello World!\") puts markdown.to_html ​``` ","date":"2020-02-20","objectID":"/markdown-reference/:2:6","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Math Blocks You can render LaTeX mathematical expressions using MathJax. To add a mathematical expression, input $$ and press the ‘Return’ key. This will trigger an input field which accepts Tex/LaTex source. For example: $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026 \\mathbf{j} \u0026 \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} \u0026 \\frac{\\partial Y}{\\partial u} \u0026 0 \\ \\frac{\\partial X}{\\partial v} \u0026 \\frac{\\partial Y}{\\partial v} \u0026 0 \\ \\end{vmatrix} $$ In the markdown source file, the math block is a LaTeX expression wrapped by a pair of ‘$$’ marks: $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026 \\mathbf{j} \u0026 \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} \u0026 \\frac{\\partial Y}{\\partial u} \u0026 0 \\\\ \\frac{\\partial X}{\\partial v} \u0026 \\frac{\\partial Y}{\\partial v} \u0026 0 \\\\ \\end{vmatrix} $$ You can find more details here. ","date":"2020-02-20","objectID":"/markdown-reference/:2:7","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Tables Input | First Header | Second Header | and press the return key. This will create a table with two columns. After a table is created, putting focus on that table will open up a toolbar for the table where you can resize, align, or delete the table. You can also use the context menu to copy and add/delete individual columns/rows. The full syntax for tables is described below, but it is not necessary to know the full syntax in detail as the markdown source code for tables is generated automatically by Typora. In markdown source code, they look like: | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | You can also include inline Markdown such as links, bold, italics, or strikethrough in the table. Finally, by including colons (:) within the header row, you can define text in that column to be left-aligned, right-aligned, or center-aligned: | Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is | some wordy text | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column. ","date":"2020-02-20","objectID":"/markdown-reference/:2:8","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Footnotes You can create footnotes like this[^footnote]. [^footnote]: Here is the *text* of the **footnote**. will produce: You can create footnotes like this1. Hover over the ‘footnote’ superscript to see content of the footnote. ","date":"2020-02-20","objectID":"/markdown-reference/:2:9","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Horizontal Rules Inputting *** or --- on a blank line and pressing return will draw a horizontal line. ","date":"2020-02-20","objectID":"/markdown-reference/:2:10","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"YAML Front Matter Typora now supports YAML Front Matter. Input --- at the top of the article and then press Return to introduce a metadata block. Alternatively, you can insert a metadata block from the top menu of Typora. ","date":"2020-02-20","objectID":"/markdown-reference/:2:11","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Table of Contents (TOC) Input [toc] and press the Return key. This will create a “Table of Contents” section. The TOC extracts all headers from the document, and its contents are updated automatically as you add to the document. ","date":"2020-02-20","objectID":"/markdown-reference/:2:12","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Span Elements Span elements will be parsed and rendered right after typing. Moving the cursor in middle of those span elements will expand those elements into markdown source. Below is an explanation of the syntax for each span element. ","date":"2020-02-20","objectID":"/markdown-reference/:3:0","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Links Markdown supports two styles of links: inline and reference. In both styles, the link text is delimited by [square brackets]. To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example: This is [an example](http://example.com/ \"Title\") inline link. [This link](http://example.net/) has no title attribute. will produce: This is an example inline link. (\u003cp\u003eThis is \u003ca href=\"http://example.com/\" title=\"Title\"\u003e) This link has no title attribute. (\u003cp\u003e\u003ca href=\"http://example.net/\"\u003eThis link\u003c/a\u003e has no) Internal Links You can set the href to headers, which will create a bookmark that allow you to jump to that section after clicking. For example: Command(on Windows: Ctrl) + Click This link will jump to header Block Elements. To see how to write that, please move cursor or click that link with ⌘ key pressed to expand the element into markdown source. Reference Links Reference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link: This is [an example][id] reference-style link. Then, anywhere in the document, you define your link label on a line by itself like this: [id]: http://example.com/ \"Optional Title Here\" In Typora, they will be rendered like so: This is an example reference-style link. The implicit link name shortcut allows you to omit the name of the link, in which case the link text itself is used as the name. Just use an empty set of square brackets — for example, to link the word “Google” to the google.com web site, you could simply write: [Google][] And then define the link: [Google]: http://google.com/ In Typora, clicking the link will expand it for editing, and command+click will open the hyperlink in your web browser. ","date":"2020-02-20","objectID":"/markdown-reference/:3:1","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"URLs Typora allows you to insert URLs as links, wrapped by \u003cbrackets\u003e. \u003ci@typora.io\u003e becomes i@typora.io. Typora will also automatically link standard URLs. e.g: www.google.com. ","date":"2020-02-20","objectID":"/markdown-reference/:3:2","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Images Images have similar syntax as links, but they require an additional ! char before the start of the link. The syntax for inserting an image looks like this: ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg \"Optional title\") You are able to use drag \u0026 drop to insert an image from an image file or your web browser. You can modify the markdown source code by clicking on the image. A relative path will be used if the image that is added using drag \u0026 drop is in same directory or sub-directory as the document you’re currently editing. If you’re using markdown for building websites, you may specify a URL prefix for the image preview on your local computer with property typora-root-url in YAML Front Matters. For example, input typora-root-url:/User/Abner/Website/typora.io/ in YAML Front Matters, and then ![alt](/blog/img/test.png) will be treated as ![alt](file:///User/Abner/Website/typora.io/blog/img/test.png) in Typora. You can find more details here. ","date":"2020-02-20","objectID":"/markdown-reference/:3:3","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Emphasis Markdown treats asterisks (*) and underscores (_) as indicators of emphasis. Text wrapped with one * or _ will be wrapped with an HTML \u003cem\u003e tag. E.g: *single asterisks* _single underscores_ output: single asterisks single underscores GFM will ignore underscores in words, which is commonly used in code and names, like this: wow_great_stuff do_this_and_do_that_and_another_thing. To produce a literal asterisk or underscore at a position where it would otherwise be used as an emphasis delimiter, you can backslash escape it: \\*this text is surrounded by literal asterisks\\* Typora recommends using the * symbol. ","date":"2020-02-20","objectID":"/markdown-reference/:3:4","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Strong A double * or _ will cause its enclosed contents to be wrapped with an HTML \u003cstrong\u003e tag, e.g: **double asterisks** __double underscores__ output: double asterisks double underscores Typora recommends using the ** symbol. ","date":"2020-02-20","objectID":"/markdown-reference/:3:5","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Code To indicate an inline span of code, wrap it with backtick quotes (`). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example: Use the `printf()` function. will produce: Use the printf() function. ","date":"2020-02-20","objectID":"/markdown-reference/:3:6","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Strikethrough GFM adds syntax to create strikethrough text, which is missing from standard Markdown. ~~Mistaken text.~~ becomes Mistaken text. ","date":"2020-02-20","objectID":"/markdown-reference/:3:7","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Underlines Underline is powered by raw HTML. \u003cu\u003eUnderline\u003c/u\u003e becomes Underline. ","date":"2020-02-20","objectID":"/markdown-reference/:3:8","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Emoji 😄 Input emoji with syntax 😄. User can trigger auto-complete suggestions for emoji by pressing ESC key, or trigger it automatically after enabling it on preference panel. Also, inputting UTF-8 emoji characters directly is also supported by going to Edit -\u003e Emoji \u0026 Symbols in the menu bar (macOS). ","date":"2020-02-20","objectID":"/markdown-reference/:3:9","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Inline Math To use this feature, please enable it first in the Preference Panel -\u003e Markdown Tab. Then, use $ to wrap a TeX command. For example: $\\lim_{x \\to \\infty} \\exp(-x) = 0$ will be rendered as LaTeX command. To trigger inline preview for inline math: input “$”, then press the ESC key, then input a TeX command. You can find more details here. ","date":"2020-02-20","objectID":"/markdown-reference/:3:10","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Subscript To use this feature, please enable it first in the Preference Panel -\u003e Markdown Tab. Then, use ~ to wrap subscript content. For example: H~2~O, X~long\\ text~/ ","date":"2020-02-20","objectID":"/markdown-reference/:3:11","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Superscript To use this feature, please enable it first in the Preference Panel -\u003e Markdown Tab. Then, use ^ to wrap superscript content. For example: X^2^. ","date":"2020-02-20","objectID":"/markdown-reference/:3:12","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Highlight To use this feature, please enable it first in the Preference Panel -\u003e Markdown Tab. Then, use == to wrap highlight content. For example: ==highlight==. ","date":"2020-02-20","objectID":"/markdown-reference/:3:13","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"HTML You can use HTML to style content what pure Markdown does not support. For example, use \u003cspan style=\"color:red\"\u003ethis text is red\u003c/span\u003e to add text with red color. ","date":"2020-02-20","objectID":"/markdown-reference/:4:0","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Embed Contents Some websites provide iframe-based embed code which you can also paste into Typora. For example: \u003ciframe height='265' scrolling='no' title='Fancy Animated SVG Menu' src='http://codepen.io/jeangontijo/embed/OxVywj/?height=265\u0026theme-id=0\u0026default-tab=css,result\u0026embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'\u003e\u003c/iframe\u003e ","date":"2020-02-20","objectID":"/markdown-reference/:4:1","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Video You can use the \u003cvideo\u003e HTML tag to embed videos. For example: \u003cvideo src=\"xxx.mp4\" /\u003e ","date":"2020-02-20","objectID":"/markdown-reference/:4:2","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Notes"],"content":"Other HTML Support You can find more details here. Here is the text of the footnote. ↩︎ ","date":"2020-02-20","objectID":"/markdown-reference/:4:3","tags":["Typora","Markdown"],"title":"Markdown For Typora","uri":"/markdown-reference/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":null,"content":"关于网站 记录生活，因为热爱，所以不舍遗忘。 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 nswy123","uri":"/about/"},{"categories":null,"content":"关于作者 nswy123 海岱人，武德充沛，喜欢打架的时候带个篮球(手动狗头)。 菜鸟通信硕士一枚，慢热喜欢安静，行事中庸，作风保守。 日常Windows10+Visual Studio/ Manjaro+Gnome+Emacs，手持随时报废的神船z7m-sl7d2 Lenovo Xiaoxin Air 14。 爱折腾，包括但不限于软路由，黑苹果等。 常用工具MATLAB，Clion，Emacs，Vim，Anki，Freeplane等。 常用技术栈C/C++，MATLAB，Python，Golang等。 喜欢五月天，周传雄，周杰伦 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于 nswy123","uri":"/about/"},{"categories":null,"content":"Email echo bnN3eTEyM0AxMjYuY29tCg== | base64 -d ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于 nswy123","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有的原创文章均受创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0保护。 版权说明 任何个人及媒体在转载本站原创内容（包含文字、自制图像、摄影作品）时请遵守以下版权要求: 注明转载 注明来源为本站(nswy123.github.io)，或转载内容所在的完整网址。 本站图片，除原创作品之外，还有一些来自互联网。此类图片的原版权所有者可在任何时候、以任何理由要求本站停止使用有关图片，其中包括被本站编辑（比如加注说明）过的图片，联系方式见上述Email。 ","date":"2019-08-02","objectID":"/about/:4:0","tags":null,"title":"关于 nswy123","uri":"/about/"},{"categories":null,"content":"Golang halfrost Blog halfrost Go LeetCode liwenzhou’blog Golang ","date":"0001-01-01","objectID":"/friendlinks/:0:1","tags":null,"title":"友链","uri":"/friendlinks/"},{"categories":null,"content":"LeetCode leetcode-cn ","date":"0001-01-01","objectID":"/friendlinks/:0:2","tags":null,"title":"友链","uri":"/friendlinks/"}]